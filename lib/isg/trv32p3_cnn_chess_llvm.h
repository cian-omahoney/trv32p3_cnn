
// File generated by noodle version U-2022.12#33f3808fcb#221128, Fri Mar 22 18:45:38 2024
// Copyright 2014-2022 Synopsys, Inc. All rights reserved.
// noodle -Pc -Iisg +wisg -D__tct_patch__=0 -Wall +NOrlt -D__chess__ -D__programmers_view__ trv32p3_cnn

#ifndef _trv32p3_cnn_chess_llvm_h
#define _trv32p3_cnn_chess_llvm_h

#pragma clang diagnostic error "-Wpointer-arith"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
#pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
#pragma clang diagnostic ignored "-Wshift-op-parentheses"
#pragma clang diagnostic ignored "-Wunused-private-field"

#define chess_protect_access __attribute__((chessLprotect_access))
// accept restrict also in C++/C89 mode
#define restrict __restrict

enum chessllvmInternal { chessllvm_reinterpret }; //overloading hook

#ifdef __cplusplus
struct chessllvmFallBack { }; //overloading hook

#define __TYPE_TRAIT(_X,_T,_DT) template <class _T> struct _X<_DT> { typedef _T type; };
template <class T> struct chessRemoveCVq                   { typedef T type; };
__TYPE_TRAIT(chessRemoveCVq, T, const T)
__TYPE_TRAIT(chessRemoveCVq, T, volatile T)
__TYPE_TRAIT(chessRemoveCVq, T, const volatile T)
template <class T> struct chessRemoveQual                  { typedef T type; };
__TYPE_TRAIT(chessRemoveQual, T, const T)
__TYPE_TRAIT(chessRemoveQual, T, volatile T)
__TYPE_TRAIT(chessRemoveQual, T, chess_protect_access T)
__TYPE_TRAIT(chessRemoveQual, T, restrict T)
__TYPE_TRAIT(chessRemoveQual, T, const volatile T)
__TYPE_TRAIT(chessRemoveQual, T, const chess_protect_access T)
__TYPE_TRAIT(chessRemoveQual, T, const restrict T)
__TYPE_TRAIT(chessRemoveQual, T, volatile restrict T)
__TYPE_TRAIT(chessRemoveQual, T, chess_protect_access restrict T)
__TYPE_TRAIT(chessRemoveQual, T, const volatile restrict T)
__TYPE_TRAIT(chessRemoveQual, T, const chess_protect_access restrict T)
template <class T> struct chessRemoveRef                   { typedef T type; };
__TYPE_TRAIT(chessRemoveRef, T, T&)
__TYPE_TRAIT(chessRemoveRef, T, T&&)
template <class T> struct chessRemovePointer               { typedef T type; };
__TYPE_TRAIT(chessRemovePointer, T, T*)
#undef __TYPE_TRAIT
template <bool b, typename T = void> struct chessEnableIf { };
template <typename T> struct chessEnableIf<true, T> { typedef T type; };
template <typename From, typename To> struct chessIsConvertible {
  static const bool value = __is_convertible(From,To);
};
template <typename, typename> struct chessEqualOrMoreQualified { static const bool value = false; };
template <typename T> struct chessEqualOrMoreQualified<T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<const T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<volatile T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<chess_protect_access T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<restrict T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<const volatile T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<const chess_protect_access T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<const restrict T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<volatile restrict T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<chess_protect_access restrict T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<const volatile restrict T,T> { static const bool value = true; }; 
template <typename T> struct chessEqualOrMoreQualified<const chess_protect_access restrict T,T> { static const bool value = true; }; 
template <typename, typename> struct chessIsCompatible { static const bool value = false; };
template <typename T> struct chessIsCompatible<T,T> { static const bool value = true; };
#endif

#ifdef __cplusplus
#define __C__ "C"
#if __cplusplus >= 201103L
#define __STUB_DEFAULT__ = default;
#else
#define __STUB_DEFAULT__ {}
#endif
#else
#define asm __asm__
#define bool _Bool
#define __C__ /**/
#endif

void chess_report(bool)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(char)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(signed char)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned char)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(short)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned short)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(int)                  __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned int)         __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(long)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned long)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(long long)            __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned long long)   __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(float)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(double)               __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(long double)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(const volatile void*) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));

void chess_assert(bool)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(char)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(signed char)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned char)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(short)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned short)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(int)                  __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned int)         __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(long)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned long)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(long long)            __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned long long)   __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(float)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(double)               __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(long double)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(const volatile void*) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));

#ifdef __cplusplus
template <typename T>
__regcall T chessLcopy(T a)       __attribute__((const)) __attribute__((nocse));
template <typename T>
inline __attribute__((always_inline,nodebug)) T chess_copy(T a) {
    static_assert(__is_trivially_copyable(T), "chess_copy requires trivially copyable type");
    return chessLcopy<T>(a);
}
template <typename T>
__regcall T chessLdont_chain(T a) __attribute__((const));
template <typename T>
inline __attribute__((always_inline,nodebug)) T chess_dont_chain(T a) {
    static_assert(__is_trivially_copyable(T), "chess_dont_chain requires trivially copyable type");
    return chessLdont_chain<T>(a);
}
template <typename T>
T chess_keep_dead(T a) __attribute__((chess_inaccessiblememonly));
template <typename T>
inline __attribute__((always_inline,nodebug)) const T& chess_dont_warn_dead(const T& a) { return a; }
#else
bool                 chess_copy      (bool)                 __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
char                 chess_copy      (char)                 __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
signed char          chess_copy      (signed char)          __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned char        chess_copy      (unsigned char)        __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
short                chess_copy      (short)                __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned short       chess_copy      (unsigned short)       __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
int                  chess_copy      (int)                  __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned int         chess_copy      (unsigned int)         __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
long                 chess_copy      (long)                 __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned long        chess_copy      (unsigned long)        __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
long long            chess_copy      (long long)            __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned long long   chess_copy      (unsigned long long)   __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
float                chess_copy      (float)                __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
double               chess_copy      (double)               __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
long double          chess_copy      (long double)          __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
void*                chess_copy      (void*)                __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
const void*          chess_copy      (const void*)          __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
volatile void*       chess_copy      (volatile void*)       __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
const volatile void* chess_copy      (const volatile void*) __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
bool                 chess_dont_chain(bool)                 __attribute__((overloadable)) __attribute__((const));
char                 chess_dont_chain(char)                 __attribute__((overloadable)) __attribute__((const));
signed char          chess_dont_chain(signed char)          __attribute__((overloadable)) __attribute__((const));
unsigned char        chess_dont_chain(unsigned char)        __attribute__((overloadable)) __attribute__((const));
short                chess_dont_chain(short)                __attribute__((overloadable)) __attribute__((const));
unsigned short       chess_dont_chain(unsigned short)       __attribute__((overloadable)) __attribute__((const));
int                  chess_dont_chain(int)                  __attribute__((overloadable)) __attribute__((const));
unsigned int         chess_dont_chain(unsigned int)         __attribute__((overloadable)) __attribute__((const));
long                 chess_dont_chain(long)                 __attribute__((overloadable)) __attribute__((const));
unsigned long        chess_dont_chain(unsigned long)        __attribute__((overloadable)) __attribute__((const));
long long            chess_dont_chain(long long)            __attribute__((overloadable)) __attribute__((const));
unsigned long long   chess_dont_chain(unsigned long long)   __attribute__((overloadable)) __attribute__((const));
float                chess_dont_chain(float)                __attribute__((overloadable)) __attribute__((const));
double               chess_dont_chain(double)               __attribute__((overloadable)) __attribute__((const));
long double          chess_dont_chain(long double)          __attribute__((overloadable)) __attribute__((const));
void*                chess_dont_chain(void*)                __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
const void*          chess_dont_chain(const void*)          __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
volatile void*       chess_dont_chain(volatile void*)       __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
const volatile void* chess_dont_chain(const volatile void*) __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
bool                 chess_keep_dead (bool)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
char                 chess_keep_dead (char)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
signed char          chess_keep_dead (signed char)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
unsigned char        chess_keep_dead (unsigned char)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
short                chess_keep_dead (short)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
unsigned short       chess_keep_dead (unsigned short)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
int                  chess_keep_dead (int)                  __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
unsigned int         chess_keep_dead (unsigned int)         __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
long                 chess_keep_dead (long)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
unsigned long        chess_keep_dead (unsigned long)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
long long            chess_keep_dead (long long)            __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
unsigned long long   chess_keep_dead (unsigned long long)   __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
float                chess_keep_dead (float)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
double               chess_keep_dead (double)               __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
long double          chess_keep_dead (long double)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void*                chess_keep_dead (void*)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly)); //BUG does not preserve complete type
const void*          chess_keep_dead (const void*)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly)); //BUG does not preserve complete type
volatile void*       chess_keep_dead (volatile void*)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly)); //BUG does not preserve complete type
const volatile void* chess_keep_dead (const volatile void*) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly)); //BUG does not preserve complete type
inline __attribute__((always_inline,nodebug)) bool                 chess_dont_warn_dead (bool a)                 __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) char                 chess_dont_warn_dead (char a)                 __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) signed char          chess_dont_warn_dead (signed char a)          __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) unsigned char        chess_dont_warn_dead (unsigned char a)        __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) short                chess_dont_warn_dead (short a)                __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) unsigned short       chess_dont_warn_dead (unsigned short a)       __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) int                  chess_dont_warn_dead (int a)                  __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) unsigned int         chess_dont_warn_dead (unsigned int a)         __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) long                 chess_dont_warn_dead (long a)                 __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) unsigned long        chess_dont_warn_dead (unsigned long a)        __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) long long            chess_dont_warn_dead (long long a)            __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) unsigned long long   chess_dont_warn_dead (unsigned long long a)   __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) float                chess_dont_warn_dead (float a)                __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) double               chess_dont_warn_dead (double a)               __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) long double          chess_dont_warn_dead (long double a)          __attribute__((overloadable)) { return a; }
inline __attribute__((always_inline,nodebug)) void*                chess_dont_warn_dead (void* a)                __attribute__((overloadable)) { return a; } //BUG does not preserve complete type
inline __attribute__((always_inline,nodebug)) const void*          chess_dont_warn_dead (const void* a)          __attribute__((overloadable)) { return a; } //BUG does not preserve complete type
inline __attribute__((always_inline,nodebug)) volatile void*       chess_dont_warn_dead (volatile void* a)       __attribute__((overloadable)) { return a; } //BUG does not preserve complete type
inline __attribute__((always_inline,nodebug)) const volatile void* chess_dont_warn_dead (const volatile void* a) __attribute__((overloadable)) { return a; } //BUG does not preserve complete type
#endif

void chess_exit(int)                       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_stop(void)                      __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_separator(void)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_no_separator_begin(void)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_no_separator_end(void)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_separator_scheduler(void)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_separator_scheduler(int)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_separator_scheduler_local(void) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_separator_scheduler_local(int)  __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_instruction_tracing_begin(void) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_instruction_tracing_end(void)   __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_profile_begin(void)             __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_profile_end(void)               __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_hosted_io(void*)                __attribute__((overloadable));

#ifdef __cplusplus
#define chess_dont_care(T) chess_dont_care_<T>()
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wuninitialized"
template <typename T>
inline __attribute__((always_inline,nodebug)) T chess_dont_care_() { T t; return t; }
#pragma clang diagnostic pop
#else
#define chess_dont_care(T) (T)0
#endif

#define __chess_pragma(x) _Pragma(#x)

#define chess_error(x) __builtin_chess_error(x)
#define chess_warning(x) __builtin_chess_warning(x)

#define chess_message(x) /*native only*/

#define chess_native(x) ((void)(bool)(x), 0/*false*/)
#define chess_manifest_or_native(x) chess_manifest(x) /*|| false*/

//  nil-defines for chess-specific keywords :

#define chess_alignof(x) (__alignof__(x))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_closed_jump_table 
#else
# define chess_closed_jump_table _Pragma("message \"'chess_closed_jump_table' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
//-nap- chess_const_eval
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_direct 
#else
# define chess_direct _Pragma("message \"'chess_direct' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_dont_warn_range(x) (x)
#define chess_flatten_loop  __chess_pragma(chessafterloop flatten_loop)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_guard 
#else
# define chess_guard _Pragma("message \"'chess_guard' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_guard_else 
#else
# define chess_guard_else _Pragma("message \"'chess_guard_else' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_indirect_jump_back  __chess_pragma(chessafterloop indirect_jump_back)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_inline_src_refs 
#else
# define chess_inline_src_refs _Pragma("message \"'chess_inline_src_refs' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_keep_if 
#else
# define chess_keep_if _Pragma("message \"'chess_keep_if' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_keep_sw_loop __chess_pragma(chessafterloop keep_sw_loop)
#define chess_keep_sw_loop2 __chess_pragma(chessafterloop keep_sw_loop2)
#define chess_loop_count(x)   __chess_pragma(chessafterloop min_loop_count(x) max_loop_count(x))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_loop_count_storage(x) 
#else
# define chess_loop_count_storage(x) _Pragma("message \"'chess_loop_count_storage(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_loop_range(x,y) __chess_pragma(chessafterloop min_loop_count(x) max_loop_count(y))
#define chess_manifest(x) __builtin_chess_manifest(x)
#define chess_const(x) __builtin_chess_const(x)
#define chess_may_alias __attribute__((may_alias))
#define chess_memory_fence() __builtin_chess_memory_fence()
#define chess_no_hw_loop __chess_pragma(chessafterloop no_hw_loop)
#define chess_no_zloop __chess_pragma(chessafterloop no_zloop)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_no_inline_src_refs 
#else
# define chess_no_inline_src_refs _Pragma("message \"'chess_no_inline_src_refs' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_no_jump_table 
#else
# define chess_no_jump_table _Pragma("message \"'chess_no_jump_table' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_open_jump_table 
#else
# define chess_open_jump_table _Pragma("message \"'chess_open_jump_table' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_output
#define chess_no_loop_transforms  __chess_pragma(chessafterloop no_loop_transforms)
#define chess_no_pipelining  __chess_pragma(chessafterloop no_pipelining)
#define chess_prepare_for_pipelining  __chess_pragma(chessafterloop prepare_for_pipelining)
#define chess_no_prepare_for_pipelining __chess_pragma(chessafterloop no_prepare_for_pipelining)
#define chess_no_unroll __chess_pragma(chessafterloop no_unroll)
#define chess_no_warn_pipelining __chess_pragma(chessafterloop no_warn_pipelining)
#define chess_no_warn_unroll __chess_pragma(chessafterloop no_warn_unroll)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_protect(x) (x)
#else
# define chess_protect(x) _Pragma("message \"'chess_protect(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")(x)
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_protect_brk_cnt /*anachronistic*/
#else
# define chess_protect_brk_cnt _Pragma("message \"'chess_protect_brk_cnt' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")/*anachronistic*/
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_redirect 
#else
# define chess_redirect _Pragma("message \"'chess_redirect' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
//-nap- chess_relocator
//-nap- chess_rewrite
#define chess_require_pipelining(x) __chess_pragma(chessafterloop require_pipelining(x))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_sequential 
#else
# define chess_sequential _Pragma("message \"'chess_sequential' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_single_instruction_repeat __chess_pragma(chessafterloop single_instruction_repeat)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_stack 
#else
# define chess_stack _Pragma("message \"'chess_stack' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_symbol(x) 0/*false*/
//-nap- chess_tcl_break(x) (?)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_unassign(x) (x)
#else
# define chess_unassign(x) _Pragma("message \"'chess_unassign(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")(x)
#endif
#define chess_unroll_loop(x) __chess_pragma(chessafterloop unroll_loop(x))
#define chess_unroll_loop_preamble __chess_pragma(chessafterloop unroll_loop_preamble)
#define chess_modulo_scheduling_budget_ratio(x) __chess_pragma(chessafterloop modulo_scheduling_budget_ratio(x))
#define chess_pipeline_adjust_preamble(x) __chess_pragma(chessafterloop pipeline_adjust_preamble(x))
#define chess_pipeline_initiation_interval(x) __chess_pragma(chessafterloop pipeline_initiation_interval(x))
#define chess_pipeline_non_leaf_loop_solution(x) __chess_pragma(chessafterloop pipeline_non_leaf_loop_solution(x))
#define chess_peel_pipelined_loop(x) __chess_pragma(chessafterloop peel_pipelined_loop(x))
#define chess_require_postamble  __chess_pragma(chessafterloop require_postamble)
#define chess_used __attribute__((used))
#define chess_gp_excluded __attribute__((chessLgp_excluded))
#define chess_weak __attribute__((weak))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_vector_guard 
#else
# define chess_vector_guard _Pragma("message \"'chess_vector_guard' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_vector_guard_else 
#else
# define chess_vector_guard_else _Pragma("message \"'chess_vector_guard_else' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_vector_sequential 
#else
# define chess_vector_sequential _Pragma("message \"'chess_vector_sequential' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif

// g++ and VC++ 8.0 or newer support variadic macro arguments
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_string_segment(...) 
#else
# define chess_string_segment(...) _Pragma("message \"'chess_string_segment(...)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif

// chess_storage annotations
#define chess_storage(...)          __attribute__((chessLstorage(__VA_ARGS__)))
// auxiliary macro to stringify macro arguments (after expansion)
#define chessLstr(...)              #__VA_ARGS__
// function pass-through attributes
#define property(...)               __attribute__((chessFP(property,chessLstr(__VA_ARGS__))))
#ifndef CHESS_CXX_ATTRIBUTES
#define clobbers(...)               __attribute__((chessFP(clobbers,chessLstr(__VA_ARGS__))))
#define clobbers_not(...)           __attribute__((chessFP(clobbers_not,chessLstr(__VA_ARGS__))))
#define value_across_call(...)      __attribute__((chessFP(value_across_call,chessLstr(__VA_ARGS__))))
#define value_across_call_not(...)  __attribute__((chessFP(value_across_call_not,chessLstr(__VA_ARGS__))))
#endif
// function pass-through attributes (new)
#define chess_clobbers(...)               __attribute__((chessFP(clobbers,chessLstr(__VA_ARGS__))))
#define chess_clobbers_not(...)           __attribute__((chessFP(clobbers_not,chessLstr(__VA_ARGS__))))
#define chess_property(...)               __attribute__((chessFP(property,chessLstr(__VA_ARGS__))))
#define chess_value_across_call(...)      __attribute__((chessFP(value_across_call,chessLstr(__VA_ARGS__))))
#define chess_value_across_call_not(...)  __attribute__((chessFP(value_across_call_not,chessLstr(__VA_ARGS__))))
// chess_extra_options annotation
#define chess_extra_options(x)    __attribute__((chessLextra_options(x)))

unsigned long long chess_cycle_count(void) __attribute__((overloadable));



//  Application types (declaration)



//  Application types (additional) (declaration)

#ifndef do_not_generate_additional_appl_types /*trouble-shooting hook*/

//!typedef float float32_t;

//!typedef double float64_t;

#endif /*do_not_generate_additional_appl_types*/



//  Application types (definition)

//  Application types (additional) (definition)

#ifndef do_not_generate_additional_appl_types /*trouble-shooting hook*/

#endif /*do_not_generate_additional_appl_types*/



//  Application types (traits)

#ifdef __cplusplus

template<typename T> struct chessTraitsOf;  // generated for each fundamental type

// chess_bitsof and chess_elementsof are sizeof-like operators that can be called
// either with a type or an expression argument, using the typeof language extension supported by llvm
#define chess_bitsof(x)     chessTraitsOf<typename chessRemoveCVq<typename chessRemoveRef<__typeof__(x)>::type>::type>::bits
#define chess_elementsof(x) chessTraitsOf<typename chessRemoveCVq<typename chessRemoveRef<__typeof__(x)>::type>::type>::elems

#else /*!__cplusplus*/

#define chess_bitsof(x)     (sizeof(x) * __CHAR_BIT__) //STUB

#endif /*__cplusplus*/

#ifndef do_not_generate_chess_traitsof /*trouble-shooting hook*/
#ifdef __cplusplus
template <> struct chessTraitsOf<bool> {
    static __constexpr unsigned bits = 1;
};
template <> struct chessTraitsOf<char> {
    static __constexpr unsigned bits = 8;
};
template <> struct chessTraitsOf<signed char> {
    static __constexpr unsigned bits = 8;
};
template <> struct chessTraitsOf<unsigned char> {
    static __constexpr unsigned bits = 8;
};
template <> struct chessTraitsOf<short> {
    static __constexpr unsigned bits = 16;
};
template <> struct chessTraitsOf<unsigned short> {
    static __constexpr unsigned bits = 16;
};
template <> struct chessTraitsOf<int> {
    static __constexpr unsigned bits = 32;
};
template <> struct chessTraitsOf<unsigned> {
    static __constexpr unsigned bits = 32;
};
template <> struct chessTraitsOf<long> {
    static __constexpr unsigned bits = 32;
};
template <> struct chessTraitsOf<unsigned long> {
    static __constexpr unsigned bits = 32;
};
template <> struct chessTraitsOf<long long> {
    static __constexpr unsigned bits = 64;
};
template <> struct chessTraitsOf<unsigned long long> {
    static __constexpr unsigned bits = 64;
};
template <> struct chessTraitsOf<float> {
    static __constexpr unsigned bits = 32;
};
template <> struct chessTraitsOf<double> {
    static __constexpr unsigned bits = 64;
};
template <> struct chessTraitsOf<long double> {
    static __constexpr unsigned bits = 64;
};
//!template <> struct chessTraitsOf<void *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(PMb) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(PM) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(DMb) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(DMh) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(DMw) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(DMb_stat) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(DMh_stat) *> {
//!    static __constexpr unsigned bits = 32;
//!};
//!template <> struct chessTraitsOf<void chess_storage(DMw_stat) *> {
//!    static __constexpr unsigned bits = 32;
//!};
#endif /*__cplusplus*/
#endif /*!do_not_generate_chess_traitsof*/

//  Reserved register variables

#ifndef do_not_generate_res_reg_vars /*trouble-shooting hook*/

#endif /*!do_not_generate_res_reg_vars*/

//  Extern variables

#ifndef do_not_generate_ext_vars /*trouble-shooting hook*/
#endif /*do_not_generate_ext_vars*/

//  Operations

extern __C__ __regcall int chessintr___sint_mulh___sint___sint(int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int mulh(int a0, int a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___sint_mulh___sint___sint(a0, a1);
}


extern __C__ __regcall unsigned chessintr___uint_mulh___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned mulh(unsigned a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_mulh___uint___uint(a0, a1);
}


extern __C__ __regcall int chessintr___sint_mulh___sint___uint(int, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int mulh(int a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___sint_mulh___sint___uint(a0, a1);
}





#if 0//dont_generate
#ifdef __cplusplus
namespace trv32p3_cnn_primitive {
extern __C__ __regcall unsigned chessintr___uint_add___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned add(unsigned a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_add___uint___uint(a0, a1);
}
} //namespace trv32p3_cnn_primitive
#endif
#endif //dont_generate


#if 0//dont_generate
#ifdef __cplusplus
namespace trv32p3_cnn_primitive {
extern __C__ __regcall unsigned chessintr___uint_sub___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned sub(unsigned a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_sub___uint___uint(a0, a1);
}
} //namespace trv32p3_cnn_primitive
#endif
#endif //dont_generate








#if 0//dont_generate
#ifdef __cplusplus
namespace trv32p3_cnn_primitive {
extern __C__ __regcall unsigned chessintr___uint_mulh___sint___sint(int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned mulh(int a0, int a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_mulh___sint___sint(a0, a1);
}
} //namespace trv32p3_cnn_primitive
#endif
#endif //dont_generate


#if 0//dont_generate
#ifdef __cplusplus
namespace trv32p3_cnn_primitive {
extern __C__ __regcall unsigned chessintr___uint_mulhu___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned mulhu(unsigned a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_mulhu___uint___uint(a0, a1);
}
} //namespace trv32p3_cnn_primitive
#endif
#endif //dont_generate


#if 0//dont_generate
#ifdef __cplusplus
namespace trv32p3_cnn_primitive {
extern __C__ __regcall unsigned chessintr___uint_mul___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned mul(unsigned a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_mul___uint___uint(a0, a1);
}
} //namespace trv32p3_cnn_primitive
#endif
#endif //dont_generate




#if 0//dont_generate
extern __C__ __regcall long long chessintr___slonglong_lmul___sint___sint(int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) long long lmul(int a0, int a1) __attribute__((overloadable))
{
    return chessintr___slonglong_lmul___sint___sint(a0, a1);
}
#endif //dont_generate











#if 0//dont_generate
#ifdef __cplusplus
struct chessout___slonglong_div_called____slonglong___slonglong___slonglong {
    long long o0 __attribute__((packed));
    long long o1 __attribute__((packed));
} __attribute__((packed));
extern __C__ __regcall struct chessout___slonglong_div_called____slonglong___slonglong___slonglong chessintr___slonglong_div_called____slonglong___slonglong___slonglong(long long, long long) __attribute__((const));
template <typename R2>
inline __attribute__((always_inline,nodebug)) typename chessEnableIf<chessIsCompatible<typename chessRemoveQual<R2>::type, long long>::value, long long>::type div_called_(long long a0, long long a1, R2 &a2) __attribute__((overloadable))
{
    struct chessout___slonglong_div_called____slonglong___slonglong___slonglong out = chessintr___slonglong_div_called____slonglong___slonglong___slonglong(a0, a1);
    a2 = out.o1;
    return out.o0;
}
#endif
#endif //dont_generate


#if 0//dont_generate
#ifdef __cplusplus
struct chessout___ulonglong_div_called____ulonglong___ulonglong___ulonglong {
    unsigned long long o0 __attribute__((packed));
    unsigned long long o1 __attribute__((packed));
} __attribute__((packed));
extern __C__ __regcall struct chessout___ulonglong_div_called____ulonglong___ulonglong___ulonglong chessintr___ulonglong_div_called____ulonglong___ulonglong___ulonglong(unsigned long long, unsigned long long) __attribute__((const));
template <typename R2>
inline __attribute__((always_inline,nodebug)) typename chessEnableIf<chessIsCompatible<typename chessRemoveQual<R2>::type, unsigned long long>::value, unsigned long long>::type div_called_(unsigned long long a0, unsigned long long a1, R2 &a2) __attribute__((overloadable))
{
    struct chessout___ulonglong_div_called____ulonglong___ulonglong___ulonglong out = chessintr___ulonglong_div_called____ulonglong___ulonglong___ulonglong(a0, a1);
    a2 = out.o1;
    return out.o0;
}
#endif
#endif //dont_generate


extern __C__ __regcall int chessintr___sint_slt___sint___sint(int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int slt(int a0, int a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___sint_slt___sint___sint(a0, a1);
}


extern __C__ __regcall int chessintr___sint_slt___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int slt(unsigned a0, unsigned a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___sint_slt___uint___uint(a0, a1);
}


extern __C__ __regcall int chessintr___sint_seq0___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int seq0(int a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___sint_seq0___sint(a0);
}


extern __C__ __regcall int chessintr___sint_sne0___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int sne0(int a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___sint_sne0___sint(a0);
}



#if 0//dont_generate
extern __C__ __regcall int chessintr___sint_chess_bitfield_extract_signed___sint___sint___sint(int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int chess_bitfield_extract_signed(int a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___sint_chess_bitfield_extract_signed___sint___sint___sint(a0, a1, a2);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall unsigned chessintr___uint_chess_bitfield_extract_unsigned___sint___sint___sint(int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned chess_bitfield_extract_unsigned(int a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___uint_chess_bitfield_extract_unsigned___sint___sint___sint(a0, a1, a2);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall int chessintr___sint_chess_bitfield_update___sint___sint___sint___sint(int, int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int chess_bitfield_update(int a0, int a1, int a2, int a3) __attribute__((overloadable))
{
    return chessintr___sint_chess_bitfield_update___sint___sint___sint___sint(a0, a1, a2, a3);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall int chessintr___sint_wrap_f32_to_i32___ffloat(float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int wrap_f32_to_i32(float32_t a0) __attribute__((overloadable))
{
    return chessintr___sint_wrap_f32_to_i32___ffloat(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall unsigned chessintr___uint_wrap_f32_to_ui32___ffloat(float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned wrap_f32_to_ui32(float32_t a0) __attribute__((overloadable))
{
    return chessintr___uint_wrap_f32_to_ui32___ffloat(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_i32_to_f32___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_i32_to_f32(int a0) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_i32_to_f32___sint(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_ui32_to_f32___uint(unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_ui32_to_f32(unsigned a0) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_ui32_to_f32___uint(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall long long chessintr___slonglong_wrap_f32_to_i64___ffloat(float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) long long wrap_f32_to_i64(float32_t a0) __attribute__((overloadable))
{
    return chessintr___slonglong_wrap_f32_to_i64___ffloat(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall unsigned long long chessintr___ulonglong_wrap_f32_to_ui64___ffloat(float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned long long wrap_f32_to_ui64(float32_t a0) __attribute__((overloadable))
{
    return chessintr___ulonglong_wrap_f32_to_ui64___ffloat(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_i64_to_f32___slonglong(long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_i64_to_f32(long long a0) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_i64_to_f32___slonglong(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_ui64_to_f32___ulonglong(unsigned long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_ui64_to_f32(unsigned long long a0) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_ui64_to_f32___ulonglong(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_f32_add___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_f32_add(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_f32_add___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_f32_sub___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_f32_sub(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_f32_sub___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_f32_mul___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_f32_mul(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_f32_mul___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_f32_div___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_f32_div(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_f32_div___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall bool chessintr_bool_wrap_f32_lt___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool wrap_f32_lt(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr_bool_wrap_f32_lt___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall bool chessintr_bool_wrap_f32_le___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool wrap_f32_le(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr_bool_wrap_f32_le___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall bool chessintr_bool_wrap_f32_eq___ffloat___ffloat(float32_t, float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool wrap_f32_eq(float32_t a0, float32_t a1) __attribute__((overloadable))
{
    return chessintr_bool_wrap_f32_eq___ffloat___ffloat(a0, a1);
}
#endif //dont_generate


extern __C__ __regcall int chessintr___sint_as_int32___ffloat(float) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int as_int32(float a0) __attribute__((overloadable))
{
    return chessintr___sint_as_int32___ffloat(a0);
}


extern __C__ __regcall float chessintr___ffloat_as_float___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float as_float(int a0) __attribute__((overloadable))
{
    return chessintr___ffloat_as_float___sint(a0);
}


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_f64_add___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_f64_add(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_f64_add___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_f64_sub___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_f64_sub(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_f64_sub___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_f64_mul___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_f64_mul(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_f64_mul___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_f64_div___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_f64_div(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_f64_div___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall bool chessintr_bool_wrap_f64_lt___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool wrap_f64_lt(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr_bool_wrap_f64_lt___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall bool chessintr_bool_wrap_f64_le___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool wrap_f64_le(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr_bool_wrap_f64_le___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall bool chessintr_bool_wrap_f64_eq___fdouble___fdouble(float64_t, float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool wrap_f64_eq(float64_t a0, float64_t a1) __attribute__((overloadable))
{
    return chessintr_bool_wrap_f64_eq___fdouble___fdouble(a0, a1);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_f32_to_f64___ffloat(float32_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_f32_to_f64(float32_t a0) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_f32_to_f64___ffloat(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float32_t chessintr___ffloat_wrap_f64_to_f32___fdouble(float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32_t wrap_f64_to_f32(float64_t a0) __attribute__((overloadable))
{
    return chessintr___ffloat_wrap_f64_to_f32___fdouble(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall int chessintr___sint_wrap_f64_to_i32___fdouble(float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int wrap_f64_to_i32(float64_t a0) __attribute__((overloadable))
{
    return chessintr___sint_wrap_f64_to_i32___fdouble(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall unsigned chessintr___uint_wrap_f64_to_ui32___fdouble(float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned wrap_f64_to_ui32(float64_t a0) __attribute__((overloadable))
{
    return chessintr___uint_wrap_f64_to_ui32___fdouble(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_i32_to_f64___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_i32_to_f64(int a0) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_i32_to_f64___sint(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_ui32_to_f64___uint(unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_ui32_to_f64(unsigned a0) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_ui32_to_f64___uint(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall long long chessintr___slonglong_wrap_f64_to_i64___fdouble(float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) long long wrap_f64_to_i64(float64_t a0) __attribute__((overloadable))
{
    return chessintr___slonglong_wrap_f64_to_i64___fdouble(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall unsigned long long chessintr___ulonglong_wrap_f64_to_ui64___fdouble(float64_t) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned long long wrap_f64_to_ui64(float64_t a0) __attribute__((overloadable))
{
    return chessintr___ulonglong_wrap_f64_to_ui64___fdouble(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_i64_to_f64___slonglong(long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_i64_to_f64(long long a0) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_i64_to_f64___slonglong(a0);
}
#endif //dont_generate


#if 0//dont_generate
extern __C__ __regcall float64_t chessintr___fdouble_wrap_ui64_to_f64___ulonglong(unsigned long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64_t wrap_ui64_to_f64(unsigned long long a0) __attribute__((overloadable))
{
    return chessintr___fdouble_wrap_ui64_to_f64___ulonglong(a0);
}
#endif //dont_generate


extern __C__ __regcall long long chessintr___slonglong_as_int64___fdouble(double) __attribute__((const));
inline __attribute__((always_inline,nodebug)) long long as_int64(double a0) __attribute__((overloadable))
{
    return chessintr___slonglong_as_int64___fdouble(a0);
}


extern __C__ __regcall double chessintr___fdouble_as_double___slonglong(long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) double as_double(long long a0) __attribute__((overloadable))
{
    return chessintr___fdouble_as_double___slonglong(a0);
}


#if 0//dont_generate
#ifdef __cplusplus
struct chessout_void_signed_div_magic___sint___sint___sint_bool {
    int o1 __attribute__((packed));
    int o2 __attribute__((packed));
    bool o3 __attribute__((packed));
} __attribute__((packed));
extern __C__ __regcall struct chessout_void_signed_div_magic___sint___sint___sint_bool chessintr_void_signed_div_magic___sint___sint___sint_bool(int) __attribute__((const));
template <typename R1, typename R2, typename R3>
inline __attribute__((always_inline,nodebug)) typename chessEnableIf<chessIsCompatible<typename chessRemoveQual<R1>::type, int>::value && chessIsCompatible<typename chessRemoveQual<R2>::type, int>::value && chessIsCompatible<typename chessRemoveQual<R3>::type, bool>::value, void>::type signed_div_magic(int a0, R1 &a1, R2 &a2, R3 &a3) __attribute__((overloadable))
{
    struct chessout_void_signed_div_magic___sint___sint___sint_bool out = chessintr_void_signed_div_magic___sint___sint___sint_bool(a0);
    a1 = out.o1;
    a2 = out.o2;
    a3 = out.o3;
    return ;
}
#endif
#endif //dont_generate


#if 0//dont_generate
#ifdef __cplusplus
struct chessout_void_unsigned_div_magic___uint___uint___sint_bool {
    unsigned o1 __attribute__((packed));
    int o2 __attribute__((packed));
    bool o3 __attribute__((packed));
} __attribute__((packed));
extern __C__ __regcall struct chessout_void_unsigned_div_magic___uint___uint___sint_bool chessintr_void_unsigned_div_magic___uint___uint___sint_bool(unsigned) __attribute__((const));
template <typename R1, typename R2, typename R3>
inline __attribute__((always_inline,nodebug)) typename chessEnableIf<chessIsCompatible<typename chessRemoveQual<R1>::type, unsigned>::value && chessIsCompatible<typename chessRemoveQual<R2>::type, int>::value && chessIsCompatible<typename chessRemoveQual<R3>::type, bool>::value, void>::type unsigned_div_magic(unsigned a0, R1 &a1, R2 &a2, R3 &a3) __attribute__((overloadable))
{
    struct chessout_void_unsigned_div_magic___uint___uint___sint_bool out = chessintr_void_unsigned_div_magic___uint___uint___sint_bool(a0);
    a1 = out.o1;
    a2 = out.o2;
    a3 = out.o3;
    return ;
}
#endif
#endif //dont_generate




extern __C__ __regcall int chessintr___sint_MyMAC___sint___sint___sint(int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int MyMAC(int a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___sint_MyMAC___sint___sint___sint(a0, a1, a2);
}


extern __C__ __regcall int chessintr___sint_exp___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int exp(int a0) __attribute__((overloadable))
{
    return chessintr___sint_exp___sint(a0);
}




#pragma chess_implicit_nodebug push

// do_generate[_llvm] inline functions (declaration)

inline __attribute__((always_inline)) int mulh(unsigned, int) __attribute__((overloadable));

inline __attribute__((always_inline)) int sle(int, int) __attribute__((overloadable));

inline __attribute__((always_inline)) int sle(unsigned, unsigned) __attribute__((overloadable));

inline __attribute__((always_inline)) int sge(int, int) __attribute__((overloadable));

inline __attribute__((always_inline)) int sge(unsigned, unsigned) __attribute__((overloadable));

inline __attribute__((always_inline)) int sgt(int, int) __attribute__((overloadable));

inline __attribute__((always_inline)) int sgt(unsigned, unsigned) __attribute__((overloadable));

inline __attribute__((always_inline)) int sne(int, int) __attribute__((overloadable));

inline __attribute__((always_inline)) int seq(int, int) __attribute__((overloadable));



// do_generate[_llvm] inline functions (definition)

    inline __attribute__((always_inline)) int mulh(unsigned a, int b) __attribute__((overloadable))
    {
     return mulh(b,a);
    }

    inline __attribute__((always_inline)) int sle(int a, int b) __attribute__((overloadable))
    {
     return slt(b,a) ^ 1;
    }

    inline __attribute__((always_inline)) int sle(unsigned a, unsigned b) __attribute__((overloadable))
    {
     return slt(b,a) ^ 1;
    }

    inline __attribute__((always_inline)) int sge(int a, int b) __attribute__((overloadable))
    {
     return slt(a,b) ^ 1;
    }

    inline __attribute__((always_inline)) int sge(unsigned a, unsigned b) __attribute__((overloadable))
    {
     return slt(a,b) ^ 1;
    }

    inline __attribute__((always_inline)) int sgt(int a, int b) __attribute__((overloadable))
    {
     return slt(b,a);
    }

    inline __attribute__((always_inline)) int sgt(unsigned a, unsigned b) __attribute__((overloadable))
    {
     return slt(b,a);
    }

    inline __attribute__((always_inline)) int sne(int a, int b) __attribute__((overloadable))
    {
     return sne0(a - b);
    }

    inline __attribute__((always_inline)) int seq(int a, int b) __attribute__((overloadable))
    {
     return seq0(a - b);
    }

#ifndef do_not_generate_member_fn_defns /*trouble-shooting hook*/
#ifdef __cplusplus
#if 0//not yet
    inline __attribute__((always_inline)) trv32p3_cnn_primitive::dint::dint(unsigned l, unsigned h) __attribute__((overloadable))
    : low(l), high(h)
    {
    }
#endif
#endif

#endif

#undef __C__
#ifdef __cplusplus
#undef __STUB_DEFAULT__
#else
#undef bool
#endif

#pragma chess_implicit_nodebug pop
#pragma clang diagnostic pop

#endif /*_trv32p3_cnn_chess_llvm_h*/
