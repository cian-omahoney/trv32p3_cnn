
-- File generated by Go version U-2022.12#33f3808fcb#221128, Wed Feb 21 13:01:39 2024
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- go -I../lib -F -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 -VHDL -otrv32p3_cnn_vhdl -cgo_options.cfg -Itrv32p3_cnn_vhdl/tmp_pdg -updg -updg_controller trv32p3_cnn



architecture behavioural of tb_mem_eDM is

  function image (constant arg : integer) return string is
    variable result : string (1 to 10) := ( others => ' ');
    variable val : integer := arg;
    variable neg : boolean := arg < 0;
    variable count : integer := result'right + 1;
  begin
    loop
      count := count -1;
      result(count) := character'val(character'pos('0')
                                     + abs(val rem 10));
      val := val/10;
      exit when val = 0;
    end loop;
    if neg then
      count := count - 1;
      result(count) := '-';
    end if;
    return result(count to result'right);
  end image;

  function addr_eDM(address : integer) return integer is
    variable result : integer;
  begin
    result := address;
    if address < 0 or address >= eDM_size_gen then
      result := 0;
    end if;
    return result;
  end addr_eDM;

  procedure fstring_read(file in_file: text; res_string: out string; len : out integer) is
    variable l:         line;
    variable c:         character;
    variable is_string: boolean;
  begin
    readline(in_file, l);
    -- clear the contents of the result string
    for i in res_string'range loop
      res_string(i) := ' ';
    end loop;
    -- read all characters of the line, up to the length  
    -- of the results string
    for i in res_string'range loop
      read(l, c, is_string);
      res_string(i) := c;
      if not is_string then -- found end of line
        len := i-1;
        return;
      end if;
    end loop;
    len := res_string'high;
  end fstring_read;

  procedure concat_strings(istr1: in string; istr2: in string; ostr: out string; len: out integer) is
    variable leni1 : integer := istr1'length;
    variable leni2 : integer := istr2'length;
    variable leno  : integer := ostr'length;
  begin
    -- clear the contents of the result string
    for i in ostr'range loop
      ostr(i) := ' ';
    end loop;
    if ((leni1 + leni2) > leno) then
      report "concat strings: length (istr1+istr2) > length (ostr)" severity error;
      len := leno;
    else
      ostr(1 to leni1) := istr1;
      ostr(leni1+1 to leni1+leni2) := istr2;
      len := leni1 + leni2;
    end if;
  end concat_strings;

  procedure adjust_strings(istr: in string; ostr: out string; len: out integer) is
    variable leni : integer := istr'length;
    variable leno : integer := ostr'length;
  begin
    -- clear the contents of the result string
    for i in ostr'range loop
      ostr(i) := ' ';
    end loop;
    if (leni > leno) then
      report "adjust_strings: length (ist) > length (ostr)" severity error;
      len := leno;
    else
      ostr(1 to leni) := istr;
      len := leni;
    end if;
  end adjust_strings;

  type t_eDM is array (0 to eDM_size_gen - 1) of t_v4u8;
  signal eDM : t_eDM;

  signal edm_ld : t_uint1_t;
  signal edm_addr : t_addr;
  signal edm_rd : t_v4u8;
  signal edm_rd_DLY1 : t_v4u8;
  signal edm_st : t_uint4_t_as_vect;
  signal edm_st_nval : t_uint4_t_as_vect;
  signal edm_addr_DLY1 : t_addr;
  signal edm_wr : t_v4u8;


begin

  -- input/output port assignment
  edm_ld <= edm_ld_in;
  edm_addr <= edm_addr_in;
  edm_rd_out <= edm_rd;
  edm_st <= edm_st_in;
  edm_wr <= edm_wr_in;

  sync_mem_eDM : process (clock)
  begin
    if clock'event and clock = '1' then
      edm_rd <= edm_rd_DLY1;
      edm_addr_DLY1 <= edm_addr;
    end if;
  end process sync_mem_eDM;

  mem_read_eDM : process(eDM,
                         edm_ld,
                         edm_addr)
  begin
    edm_rd_DLY1 <= (others => '0');

    for i in 3 downto 0 loop
      if edm_ld = '1' then -- edm_ld: edm_rd `1` = eDM[edm_addr];
        edm_rd_DLY1(i*8+7 downto i*8) <= eDM(addr_eDM(to_integer(edm_addr)))(i*8+7 downto i*8);
      end if;
    end loop;
  end process mem_read_eDM;

  mem_write_eDM : process(reset, clock)
    file eDMdata : text;
    variable eDMval : t_v4u8;
    variable line_in     : line;
    variable rOK         : boolean;
    variable address     : natural;
    variable in_char     : character;
    variable in_bit      : bit;
    variable line_count  : natural;
    variable file_status : FILE_OPEN_STATUS;
    variable firstline   : boolean := true;
    variable readmemh    : boolean := false;
    variable atchar      : character;
    variable addr_hex    : std_logic_vector (23 downto 0);  -- width fixed in read_elf..
    variable data_hex    : std_logic_vector (31 downto 0);

    file     appname_file    : text;
    variable appname_fstatus : FILE_OPEN_STATUS;
    variable appname         : string(1 to 255);
    variable tmp_appname     : string(1 to 255);
    variable tmp_len         : integer;
    variable appname_len     : integer;
  begin
    if reset'event and reset /= '0' then
      eDM <= (others => (others => '0'));

      -- get the memory init file name from a file, if existing:
      file_open(appname_fstatus, appname_file, "appname.cfg", read_mode);
      if (appname_fstatus = OPEN_OK) then
        if (not endfile(appname_file)) then
          fstring_read(appname_file, tmp_appname, tmp_len);
          file_close(appname_file);
          concat_strings(tmp_appname(1 to tmp_len), ".eDM", appname, appname_len);
        end if;
      else
        adjust_strings(eDM_file_gen, appname, appname_len);
      end if;

      file_open(file_status, eDMdata, appname(1 to appname_len), read_mode);
      if file_status = OPEN_OK then
        line_count := 1;
        while not endfile(eDMdata) loop
          readline(eDMdata, line_in);

          if (firstline) then
            -- If the first char in the first line is a '@',
            -- we have a Verilog readmemh format..
            if ((line_in'length /= 0) and (line_in(1) = '@')) then
              readmemh := true;
            end if;
            firstline := false;
          end if;

          if (readmemh) then
            -- readmemh format
            rOK := true;
            while rOK loop
              if (line_in'length = 0) then
                rOK := false;
              elsif (line_in'length /= 0 and line_in(1) = '@') then
                -- Jump to new address (no space os allowed between the @ and the value):
                read (line_in, atchar); -- simply read(remove) the @ from the line..
                hread(line_in, addr_hex, rOK);
                if (rOK) then
                  address := to_integer(unsigned(addr_hex));
                end if;
              else
                -- read data:
                hread(line_in, data_hex, rOK);
                if (rOK) then
                  eDM(address) <= unsigned(data_hex(31 downto 0));
                  address := address + 1;
                end if;
              end if;
            end loop;
          else
            -- special format
            read(line_in, address, rOK);
            assert rOK
              report "Memory init. : ERROR reading eDM address, at line : " & image(line_count)
              severity failure;
            if line_in'length /= 0 then
              in_char := nul;
              while in_char /= '"' loop
              read(line_in, in_char, rOK);
              assert rOK
              report "Memory init. : ERROR reading eDM data value, at line : " & image(line_count)
              severity failure;
              end loop;

              for i in eDMval'range loop
              read(line_in, in_bit, rOK);
              assert rOK
              report "Memory init. : ERROR eDM : data value too short, at line : " & image(line_count)
              severity failure;
              if in_bit = '0' then
              eDMval(i) := '0';
              else
              eDMval(i) := '1';
              end if;
              end loop;

              read(line_in, in_char, rOK);
              assert rOK and in_char = '"'
              report "Memory init. : ERROR eDM : data value too long, at line : " & image(line_count)
              severity failure;
              eDM(address) <= eDMval;
            end if;
            line_count := line_count + 1;
          end if;
        end loop;
        file_close(eDMdata);
      else
        assert (false)
          report "Memory init. warning: Could not open file " & appname(1 to appname_len)
          severity warning;
      end if;

    end if;

    if clock'event and clock = '1' then
      edm_st_nval <= (others => '0');

      for i in 3 downto 0 loop
        if edm_st(i) = '1' then -- edm_st: eDM[edm_addr] = edm_wr;
          eDM(addr_eDM(to_integer(edm_addr)))(i*8+7 downto i*8) <= edm_wr(i*8+7 downto i*8);

          edm_st_nval(i) <= '1';
        end if;
      end loop;
    end if;
  end process mem_write_eDM;

  mem_log_eDM : process(clock)

    procedure log_eDM(addr : in integer; mem_val : in t_u08; vector_index_gen : in natural) is
      variable lline : line;
      variable val_ok : boolean := true;
    begin
      write(lline, string'("eDM_"));
      write(lline, vector_index_gen);
      write(lline, string'("["));
      write(lline, addr);
      write(lline, string'("] = "));
      for j in mem_val'range loop
        if mem_val(j) /= '0' and mem_val(j) /= '1' then
          val_ok := false;
          exit;
        end if;
      end loop;
      if val_ok then
        hwrite(lline, std_logic_vector(mem_val));
      else
        write(lline, string'("X"));
      end if;
      logfile_write(lline);
    end log_eDM;

  begin

    if clock'event and clock = '0' then
      if reg_log_gen then
        for i in 3 downto 0 loop
          if edm_st_nval(i) = '1' then
            log_eDM(addr_eDM(to_integer(edm_addr_DLY1)),
                    eDM(addr_eDM(to_integer(edm_addr_DLY1)))(i*8+7 downto i*8), i);
          end if;
        end loop;
      end if;
    end if;
  end process mem_log_eDM;

end behavioural;
