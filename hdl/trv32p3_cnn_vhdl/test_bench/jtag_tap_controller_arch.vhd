
-- File generated by Go version U-2022.12#33f3808fcb#221128, Wed Feb 21 12:29:42 2024
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- go -I../lib -F -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 -VHDL -otrv32p3_cnn_vhdl -cgo_options.cfg -Itrv32p3_cnn_vhdl/tmp_pdg -updg -updg_controller trv32p3_cnn



architecture rtl of jtag_tap_controller is

  -- JTAG reserved instructions
  constant JTAG_EXTEST_INSTR      : std_logic_vector(15 downto 0) := "0000000000000000";
  constant JTAG_RESERVED_INSTR    : std_logic_vector(15 downto 0) := "0000000000000001";
  constant JTAG_IDCODE_INSTR      : std_logic_vector(15 downto 0) := "0000000000000010";
  constant JTAG_BYPASS_INSTR      : std_logic_vector(15 downto 0) := "1111111111111111";

  -- JTAG TAP state encodings
  constant TEST_LOGIC_RESET_STATE : std_logic_vector(3 downto 0) := "0000";
  constant RUN_TEST_IDLE_STATE    : std_logic_vector(3 downto 0) := "0001";
  constant SELECT_DR_SCAN_STATE   : std_logic_vector(3 downto 0) := "0010";
  constant CAPTURE_DR_STATE       : std_logic_vector(3 downto 0) := "0011";
  constant SHIFT_DR_STATE         : std_logic_vector(3 downto 0) := "0100";
  constant EXIT1_DR_STATE         : std_logic_vector(3 downto 0) := "0101";
  constant PAUSE_DR_STATE         : std_logic_vector(3 downto 0) := "0110";
  constant EXIT2_DR_STATE         : std_logic_vector(3 downto 0) := "0111";
  constant UPDATE_DR_STATE        : std_logic_vector(3 downto 0) := "1000";
  constant SELECT_IR_SCAN_STATE   : std_logic_vector(3 downto 0) := "1001";
  constant CAPTURE_IR_STATE       : std_logic_vector(3 downto 0) := "1010";
  constant SHIFT_IR_STATE         : std_logic_vector(3 downto 0) := "1011";
  constant EXIT1_IR_STATE         : std_logic_vector(3 downto 0) := "1100";
  constant PAUSE_IR_STATE         : std_logic_vector(3 downto 0) := "1101";
  constant EXIT2_IR_STATE         : std_logic_vector(3 downto 0) := "1110";
  constant UPDATE_IR_STATE        : std_logic_vector(3 downto 0) := "1111";

  signal dbg_instr_master : std_logic_vector(15 downto 0);
  signal dbg_instr_sig : std_logic_vector(15 downto 0);
  signal dbg_instr_slave : std_logic_vector(15 downto 0);
  signal jtag_tdo_sig : std_logic;
  signal next_state : std_logic_vector(3 downto 0);
  signal state : std_logic_vector(3 downto 0);
  signal jtag_tdi_REG : std_logic;
  signal jtag_tdo_REG : std_logic;
  signal jtag_tdo_en_REG : std_logic;

begin

  -- output assignments
  dbg_instr_out <= dbg_instr_slave;
  jtag_tap_so_out <= jtag_tdi_in;

  -- spyglass disable_block W391
  -- DISABLES: W391 (Reports modules driven by both edges of a clock)
  -- REASON: According to JTAG standard IEEE 1149.1, the instruction register
  --         output shall be latched in the falling edge of TCK, also
  --         TDO shall change on the falling edge

  -- JTAG Finite State Machine
  state_update_proc : process(jtag_tck_in, jtag_trst)
  begin
    if jtag_trst /= '1' then
      state <= TEST_LOGIC_RESET_STATE;
    elsif jtag_tck_in'event and jtag_tck_in = '1' then
      state <= next_state;
    end if;

  end process state_update_proc;

  next_state_proc : process (state, jtag_tms_in)
  begin
    next_state <= TEST_LOGIC_RESET_STATE;
    case state is
      when TEST_LOGIC_RESET_STATE =>
        if jtag_tms_in = '1' then
          next_state <= TEST_LOGIC_RESET_STATE;
        else
          next_state <= RUN_TEST_IDLE_STATE;
        end if;
      when RUN_TEST_IDLE_STATE =>
        if jtag_tms_in = '1' then
          next_state <= SELECT_DR_SCAN_STATE;
        else
          next_state <= RUN_TEST_IDLE_STATE;
        end if;
      when SELECT_DR_SCAN_STATE =>
        if jtag_tms_in = '1' then
          next_state <= SELECT_IR_SCAN_STATE;
        else
          next_state <= CAPTURE_DR_STATE;
        end if;
      when CAPTURE_DR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= EXIT1_DR_STATE;
        else
          next_state <= SHIFT_DR_STATE;
        end if;
      when SHIFT_DR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= EXIT1_DR_STATE;
        else
          next_state <= SHIFT_DR_STATE;
        end if;
      when EXIT1_DR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= UPDATE_DR_STATE;
        else
          next_state <= PAUSE_DR_STATE;
        end if;
      when PAUSE_DR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= EXIT2_DR_STATE;
        else
          next_state <= PAUSE_DR_STATE;
        end if;
      when EXIT2_DR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= UPDATE_DR_STATE;
        else
          next_state <= SHIFT_DR_STATE;
        end if;
      when UPDATE_DR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= SELECT_DR_SCAN_STATE;
        else
          next_state <= RUN_TEST_IDLE_STATE;
        end if;
      when SELECT_IR_SCAN_STATE =>
        if jtag_tms_in = '1' then
          next_state <= TEST_LOGIC_RESET_STATE;
        else
          next_state <= CAPTURE_IR_STATE;
        end if;
      when CAPTURE_IR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= EXIT1_IR_STATE;
        else
          next_state <= SHIFT_IR_STATE;
        end if;
      when SHIFT_IR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= EXIT1_IR_STATE;
        else
          next_state <= SHIFT_IR_STATE;
        end if;
      when EXIT1_IR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= UPDATE_IR_STATE;
        else
          next_state <= PAUSE_IR_STATE;
        end if;
      when PAUSE_IR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= EXIT2_IR_STATE;
        else
          next_state <= PAUSE_IR_STATE;
        end if;
      when EXIT2_IR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= UPDATE_IR_STATE;
        else
          next_state <= SHIFT_IR_STATE;
        end if;
      when UPDATE_IR_STATE =>
        if jtag_tms_in = '1' then
          next_state <= SELECT_DR_SCAN_STATE;
        else
          next_state <= RUN_TEST_IDLE_STATE;
        end if;
      when others =>
        null;
    end case;
  end process next_state_proc;

  -- JTAG instruction scan register
  dbg_instr_master_input : process(state, dbg_instr_master, jtag_tdi_in)
  begin
    dbg_instr_sig <= (others => '0');
    jtag_tdo_sig <= '0';
    if state = CAPTURE_IR_STATE then
      dbg_instr_sig <= JTAG_RESERVED_INSTR;
    elsif state = SHIFT_IR_STATE then
      jtag_tdo_sig <= dbg_instr_master(0);
      for i in 0 to 14 loop
        dbg_instr_sig(i) <= dbg_instr_master(i+1);
      end loop;
      dbg_instr_sig(15) <= jtag_tdi_in;
    end if;
  end process dbg_instr_master_input;

  clock_dbg_instr_master : process(jtag_tck_in, jtag_trst)
  begin
    if jtag_trst /= '1' then
      dbg_instr_master <= (others => '0');
    elsif jtag_tck_in'event and jtag_tck_in = '1' then
      if state = CAPTURE_IR_STATE or state = SHIFT_IR_STATE then
        dbg_instr_master <= dbg_instr_sig;
      end if;
    end if;
  end process clock_dbg_instr_master;

  clock_dbg_instr_slave : process(jtag_tck_in, jtag_trst)
  begin
    if jtag_trst /= '1' then
      dbg_instr_slave <= JTAG_BYPASS_INSTR;
    elsif jtag_tck_in'event and jtag_tck_in = '0' then
      if state = TEST_LOGIC_RESET_STATE then
        dbg_instr_slave <= JTAG_BYPASS_INSTR;
      elsif state = UPDATE_IR_STATE then
        dbg_instr_slave <= dbg_instr_master;
      end if;
    end if;
  end process clock_dbg_instr_slave;

  -- control for data scan registers
  data_scan_reg_control : process(state)
  begin
    jtag_capture_dr_out <= '0';
    jtag_update_dr_out <= '0';
    jtag_shift_dr_out <= '0';
    jtag_update_ir_out <= '0';
    if state = CAPTURE_DR_STATE then
      jtag_capture_dr_out <= '1';
    end if;
    if state = UPDATE_DR_STATE then
      jtag_update_dr_out <= '1';
    end if;
    if state = SHIFT_DR_STATE then
      jtag_shift_dr_out <= '1';
    end if;
    if state = UPDATE_IR_STATE then
      jtag_update_ir_out <= '1';
    end if;
  end process data_scan_reg_control;

  -- sample tdi for bypass
  jtag_tdi_in_reg_proc : process(jtag_tck_in, jtag_trst)
    variable core_id : natural;
  begin
    if jtag_trst /= '1' then
      jtag_tdi_REG <= '0';
    elsif jtag_tck_in'event and jtag_tck_in = '1' then
      if dbg_instr_slave = JTAG_BYPASS_INSTR then
        if state = CAPTURE_DR_STATE then
          jtag_tdi_REG <= '0';
        elsif state = SHIFT_DR_STATE then
          jtag_tdi_REG <= jtag_tdi_in;
        end if;
      end if;
    end if;
  end process jtag_tdi_in_reg_proc;

  -- multiplexing and output for tdo
  jtag_tdo_out_reg_proc : process(jtag_tck_in, jtag_trst)
    variable core_id : natural;
  begin
    if jtag_trst /= '1' then
      jtag_tdo_REG <= '0';
    elsif jtag_tck_in'event and jtag_tck_in = '0' then
      if state = SHIFT_DR_STATE then
        if dbg_instr_slave = JTAG_BYPASS_INSTR then
          jtag_tdo_REG <= jtag_tdi_REG;
        else
          core_id := to_integer(unsigned(dbg_instr_slave(15 downto 11)));
          jtag_tdo_REG <= jtag_tap_si_in(core_id);
        end if;
      elsif state = SHIFT_IR_STATE then
        jtag_tdo_REG <= jtag_tdo_sig;
      end if;
    end if;
  end process jtag_tdo_out_reg_proc;

  jtag_tdo_en_REG_proc : process(jtag_tck_in, jtag_trst)
  begin
    if jtag_trst /= '1' then
      jtag_tdo_en_REG <= '0';
    elsif jtag_tck_in'event and jtag_tck_in = '0' then
      if state = SHIFT_DR_STATE or state = SHIFT_IR_STATE then
        jtag_tdo_en_REG <= '1';
      else
        jtag_tdo_en_REG <= '0';
      end if;
    end if;
  end process jtag_tdo_en_REG_proc;
  -- spyglass enable_block W391

  jtag_tdo_out <= jtag_tdo_REG when jtag_tdo_en_REG = '1' else 'Z';

end rtl;
