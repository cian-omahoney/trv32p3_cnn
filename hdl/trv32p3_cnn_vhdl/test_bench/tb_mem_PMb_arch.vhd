
-- File generated by Go version U-2022.12#33f3808fcb#221128, Wed Feb 21 17:37:19 2024
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- go -I../lib -F -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 -VHDL -otrv32p3_cnn_vhdl -cgo_options.cfg -Itrv32p3_cnn_vhdl/tmp_pdg -updg -updg_controller trv32p3_cnn



architecture behavioural of tb_mem_PMb is

  function image (constant arg : integer) return string is
    variable result : string (1 to 10) := ( others => ' ');
    variable val : integer := arg;
    variable neg : boolean := arg < 0;
    variable count : integer := result'right + 1;
  begin
    loop
      count := count -1;
      result(count) := character'val(character'pos('0')
                                     + abs(val rem 10));
      val := val/10;
      exit when val = 0;
    end loop;
    if neg then
      count := count - 1;
      result(count) := '-';
    end if;
    return result(count to result'right);
  end image;

  function addr_PMb(address : integer) return integer is
    variable result : integer;
  begin
    result := address;
    if address < 0 or address >= PMb_size_gen then
      result := 0;
    end if;
    return result;
  end addr_PMb;

  procedure fstring_read(file in_file: text; res_string: out string; len : out integer) is
    variable l:         line;
    variable c:         character;
    variable is_string: boolean;
  begin
    readline(in_file, l);
    -- clear the contents of the result string
    for i in res_string'range loop
      res_string(i) := ' ';
    end loop;
    -- read all characters of the line, up to the length  
    -- of the results string
    for i in res_string'range loop
      read(l, c, is_string);
      res_string(i) := c;
      if not is_string then -- found end of line
        len := i-1;
        return;
      end if;
    end loop;
    len := res_string'high;
  end fstring_read;

  procedure concat_strings(istr1: in string; istr2: in string; ostr: out string; len: out integer) is
    variable leni1 : integer := istr1'length;
    variable leni2 : integer := istr2'length;
    variable leno  : integer := ostr'length;
  begin
    -- clear the contents of the result string
    for i in ostr'range loop
      ostr(i) := ' ';
    end loop;
    if ((leni1 + leni2) > leno) then
      report "concat strings: length (istr1+istr2) > length (ostr)" severity error;
      len := leno;
    else
      ostr(1 to leni1) := istr1;
      ostr(leni1+1 to leni1+leni2) := istr2;
      len := leni1 + leni2;
    end if;
  end concat_strings;

  procedure adjust_strings(istr: in string; ostr: out string; len: out integer) is
    variable leni : integer := istr'length;
    variable leno : integer := ostr'length;
  begin
    -- clear the contents of the result string
    for i in ostr'range loop
      ostr(i) := ' ';
    end loop;
    if (leni > leno) then
      report "adjust_strings: length (ist) > length (ostr)" severity error;
      len := leno;
    else
      ostr(1 to leni) := istr;
      len := leni;
    end if;
  end adjust_strings;

  type t_PMb is array (0 to PMb_size_gen - 1) of t_u08;
  signal PMb : t_PMb;

  signal pm_addr : t_addr;
  signal pm_ld : std_logic;
  signal pm_rd : t_iword;
  signal pm_st : std_logic;
  signal pm_wr : t_iword;

  signal pm_addr_DLY1 : t_addr;
  signal pm_ld_DLY1 : std_logic;
  signal pm_st_nval : std_logic;

begin

  -- input/output port assignment
  pm_addr <= pm_addr_in;
  pm_ld <= pm_ld_in;
  pm_st <= pm_st_in;
  pm_wr <= pm_wr_in;
  pm_rd_out <= pm_rd;

  sync_mem_PMb : process (clock)
  begin
    if clock'event and clock = '1' then
      pm_addr_DLY1 <= pm_addr;
      pm_ld_DLY1 <= pm_ld;
    end if;
  end process sync_mem_PMb;

  mem_read_PMb : process(PMb,
                         pm_ld_DLY1,
                         pm_addr_DLY1)
  begin
    pm_rd <= (others => '0');

    if pm_ld_DLY1 = '1' then -- pm_rd_ld_PM_pm_addr___ocd_ld_PMbEX_r_EX_alw
      pm_rd <= PMb(addr_PMb(to_integer(pm_addr_DLY1) + 3)) & PMb(addr_PMb(to_integer(pm_addr_DLY1) + 2)) & PMb(addr_PMb(to_integer(pm_addr_DLY1) + 1)) & PMb(addr_PMb(to_integer(pm_addr_DLY1)));
    end if;
    -- pm_rd_rd_PM_pm_addr_pm_ld_pdg_en also uses control signal pm_ld_DLY1
  end process mem_read_PMb;

  mem_write_PMb : process(reset, clock)
    file PMbdata : text;
    variable PMbval : t_u08;
    variable line_in     : line;
    variable rOK         : boolean;
    variable address     : natural;
    variable in_char     : character;
    variable in_bit      : bit;
    variable line_count  : natural;
    variable file_status : FILE_OPEN_STATUS;
    variable firstline   : boolean := true;
    variable readmemh    : boolean := false;
    variable atchar      : character;
    variable addr_hex    : std_logic_vector (23 downto 0);  -- width fixed in read_elf..
    variable data_hex    : std_logic_vector (7 downto 0);

    file     appname_file    : text;
    variable appname_fstatus : FILE_OPEN_STATUS;
    variable appname         : string(1 to 255);
    variable tmp_appname     : string(1 to 255);
    variable tmp_len         : integer;
    variable appname_len     : integer;
  begin
    if reset'event and reset /= '0' then

      -- get the memory init file name from a file, if existing:
      file_open(appname_fstatus, appname_file, "appname.cfg", read_mode);
      if (appname_fstatus = OPEN_OK) then
        if (not endfile(appname_file)) then
          fstring_read(appname_file, tmp_appname, tmp_len);
          file_close(appname_file);
          concat_strings(tmp_appname(1 to tmp_len), ".PMb", appname, appname_len);
        end if;
      else
        adjust_strings(PMb_file_gen, appname, appname_len);
      end if;

      PMb <= (others => (others => '0'));
      file_open(file_status, PMbdata, appname(1 to appname_len), read_mode);
      if file_status = OPEN_OK then
        line_count := 1;
        while not endfile(PMbdata) loop
          readline(PMbdata, line_in);

          if (firstline) then
            -- If the first char in the first line is a '@',
            -- we have a Verilog readmemh format..
            if ((line_in'length /= 0) and (line_in(1) = '@')) then
              readmemh := true;
            end if;
            firstline := false;
          end if;

          if (readmemh) then
            -- readmemh format
            rOK := true;
            while rOK loop
              if (line_in'length = 0) then
                rOK := false;
              elsif (line_in'length /= 0 and line_in(1) = '@') then
                -- Jump to new address (no space os allowed between the @ and the value):
                read (line_in, atchar); -- simply read(remove) the @ from the line..
                hread(line_in, addr_hex, rOK);
                if (rOK) then
                  address := to_integer(unsigned(addr_hex));
                end if;
              else
                -- read data:
                hread(line_in, data_hex, rOK);
                if (rOK) then
                  PMb(address) <= unsigned(data_hex(7 downto 0));
                  address := address + 1;
                end if;
              end if;
            end loop;
          else
            -- special format
            read(line_in, address, rOK);
            assert rOK
              report "Memory init. : ERROR reading PMb address, at line : " & image(line_count)
              severity failure;
            if line_in'length /= 0 then
              in_char := nul;
              while in_char /= '"' loop
              read(line_in, in_char, rOK);
              assert rOK
              report "Memory init. : ERROR reading PMb data value, at line : " & image(line_count)
              severity failure;
              end loop;

              for i in PMbval'range loop
              read(line_in, in_bit, rOK);
              assert rOK
              report "Memory init. : ERROR PMb : data value too short, at line : " & image(line_count)
              severity failure;
              if in_bit = '0' then
              PMbval(i) := '0';
              else
              PMbval(i) := '1';
              end if;
              end loop;

              read(line_in, in_char, rOK);
              assert rOK and in_char = '"'
              report "Memory init. : ERROR PMb : data value too long, at line : " & image(line_count)
              severity failure;
              PMb(address) <= PMbval;
            end if;
            line_count := line_count + 1;
          end if;
        end loop;
        file_close(PMbdata);
      else
        assert (false)
          report "Memory init. warning: Could not open file " & appname(1 to appname_len)
          severity warning;
      end if;

    end if;

    if clock'event and clock = '1' then
      pm_st_nval <= '0';

      if pm_st = '1' then -- PM_st_pm_wr_pm_addr___ocd_st_PMbEX_r_EX_alw
        PMb(addr_PMb(to_integer(pm_addr) + 3)) <= pm_wr(31 downto 24);
        PMb(addr_PMb(to_integer(pm_addr) + 2)) <= pm_wr(23 downto 16);
        PMb(addr_PMb(to_integer(pm_addr) + 1)) <= pm_wr(15 downto 8);
        PMb(addr_PMb(to_integer(pm_addr))) <= pm_wr(7 downto 0);
        pm_st_nval <= '1';
      end if;
    end if;
  end process mem_write_PMb;

  mem_log_PMb : process(clock)

    procedure log_PMb(addr : in integer; mem_val : in t_u08) is
      variable lline : line;
      variable val_ok : boolean := true;
    begin
      write(lline, string'("PMb["));
      write(lline, addr);
      write(lline, string'("] = "));
      for j in mem_val'range loop
        if mem_val(j) /= '0' and mem_val(j) /= '1' then
          val_ok := false;
          exit;
        end if;
      end loop;
      if val_ok then
        hwrite(lline, std_logic_vector(mem_val));
      else
        write(lline, string'("X"));
      end if;
      logfile_write(lline);
    end log_PMb;

  begin

    if clock'event and clock = '0' then
      if reg_log_gen then
        if pm_st_nval = '1' then
          log_PMb(addr_PMb(to_integer(pm_addr_DLY1)),
                  PMb(addr_PMb(to_integer(pm_addr_DLY1))));
          log_PMb(addr_PMb(to_integer(pm_addr_DLY1) + 1),
                  PMb(addr_PMb(to_integer(pm_addr_DLY1) + 1)));
          log_PMb(addr_PMb(to_integer(pm_addr_DLY1) + 2),
                  PMb(addr_PMb(to_integer(pm_addr_DLY1) + 2)));
          log_PMb(addr_PMb(to_integer(pm_addr_DLY1) + 3),
                  PMb(addr_PMb(to_integer(pm_addr_DLY1) + 3)));
        end if;
      end if;
    end if;
  end process mem_log_PMb;

end behavioural;
