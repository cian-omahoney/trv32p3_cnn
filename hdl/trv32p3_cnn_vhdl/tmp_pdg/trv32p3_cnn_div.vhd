
-- File generated by pdg version U-2022.12#33f3808fcb#221128
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- pdg -I../lib -D__go__ -VHDL -cgo_options.cfg -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 +wtrv32p3_cnn_vhdl/tmp_pdg trv32p3_cnn


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library trv32p3_cnn_lib;
use trv32p3_cnn_lib.data_types.all;

entity div is
  port (
    reset : in std_logic;
    clock : in std_logic;
    div_wad_in : in t_t5u;
    divA_in : in t_w32;
    divB_in : in t_w32;
    en_divR_divs_divA_divB_div_EX : in std_logic;
    en_divR_divu_divA_divB_div_EX : in std_logic;
    en_divR_rems_divA_divB_div_EX : in std_logic;
    en_divR_remu_divA_divB_div_EX : in std_logic;
    X_x_w1_div_main_pdg_w_a_out : out t_t5unz;
    X_x_w1_div_main_pdg_en_out : out std_logic;
    x_w1_out : out t_w32;
    div_bsy_out : out std_logic;
    div_adr_out : out t_t5unz;
    div_wnc_out : out std_logic);
end div;

architecture rtl of div is
  signal B : unsigned(31 downto 0);
  signal pdg_update_B : unsigned(31 downto 0);
  signal pdg_we_B : std_logic;
  signal PA : unsigned(63 downto 0);
  signal pdg_update_PA : unsigned(63 downto 0);
  signal pdg_we_PA : std_logic;
  signal Q_addr_reg : unsigned(4 downto 0);
  signal pdg_update_Q_addr_reg : unsigned(4 downto 0);
  signal pdg_we_Q_addr_reg : std_logic;
  signal cnt : unsigned(5 downto 0);
  signal pdg_update_cnt : unsigned(5 downto 0);
  signal pdg_we_cnt : std_logic;
  signal is_div : std_logic;
  signal pdg_update_is_div : std_logic;
  signal pdg_we_is_div : std_logic;
  signal is_neg : std_logic;
  signal pdg_update_is_neg : std_logic;
  signal pdg_we_is_neg : std_logic;
begin
  p_main : process(B,
                   PA,
                   Q_addr_reg,
                   cnt,
                   divA_in,
                   divB_in,
                   div_wad_in,
                   en_divR_divs_divA_divB_div_EX,
                   en_divR_divu_divA_divB_div_EX,
                   en_divR_rems_divA_divB_div_EX,
                   en_divR_remu_divA_divB_div_EX,
                   is_div,
                   is_neg)
    variable is_divs : std_logic;
    variable is_divu : std_logic;
    variable is_rems : std_logic;
    variable is_remu : std_logic;
    variable div_start : std_logic;
    variable divA_loc : signed(31 downto 0);
    variable divB_loc : signed(31 downto 0);
    variable div_step_result : unsigned(63 downto 0);
    variable new_pa : unsigned(63 downto 0);
    variable diff : unsigned(32 downto 0);
    variable pa_0 : unsigned(63 downto 0);
    variable t : unsigned(31 downto 0);
    variable res : signed(31 downto 0);
    constant Cuint6_t_0 : unsigned(5 downto 0) := (others => '0');
    constant Cuint5_t_0 : unsigned(4 downto 0) := (others => '0');
    constant Cuint1_t_0 : std_logic := '0';
    constant Cuint6_t_33 : unsigned(5 downto 0) := "100001";
    constant Cuint6_t_1 : unsigned(5 downto 0) := "000001";
    constant Cuint1_t_1 : std_logic := '1';
    constant Cuint32_t_0 : unsigned(31 downto 0) := (others => '0');
    constant Cint32_t_m1 : signed(31 downto 0) := "11111111111111111111111111111111";
  begin
    pdg_we_B <= '0';
    pdg_update_B <= (others => '0');
    pdg_we_PA <= '0';
    pdg_update_PA <= (others => '0');
    pdg_we_Q_addr_reg <= '0';
    pdg_update_Q_addr_reg <= (others => '0');
    X_x_w1_div_main_pdg_en_out <= '0';
    X_x_w1_div_main_pdg_w_a_out <= (others => '0');
    pdg_we_cnt <= '0';
    pdg_update_cnt <= (others => '0');
    diff := (others => '0');
    divA_loc := (others => '0');
    divB_loc := (others => '0');
    div_step_result := (others => '0');
    pdg_we_is_div <= '0';
    pdg_update_is_div <= '0';
    pdg_we_is_neg <= '0';
    pdg_update_is_neg <= '0';
    new_pa := (others => '0');
    pa_0 := (others => '0');
    res := (others => '0');
    t := (others => '0');
    x_w1_out <= (others => '0');
    is_divs := en_divR_divs_divA_divB_div_EX;
    is_divu := en_divR_divu_divA_divB_div_EX;
    is_rems := en_divR_rems_divA_divB_div_EX;
    is_remu := en_divR_remu_divA_divB_div_EX;
    div_start := ((boolean_to_std_logic(cnt = Cuint6_t_0) and (((is_divs or is_divu) or is_rems) or is_remu)) and boolean_to_std_logic(div_wad_in /= Cuint5_t_0));
    if (std_logic_to_boolean(div_start)) then
      if ((std_logic_to_boolean(is_divs) or std_logic_to_boolean(is_rems))) then
        if (std_logic_to_boolean(divA_in(31))) then
          divA_loc := (-divA_in);
        else
          divA_loc := divA_in;
        end if;
        if (std_logic_to_boolean(divB_in(31))) then
          divB_loc := (-divB_in);
        else
          divB_loc := divB_in;
        end if;
        pdg_we_is_neg <= '1';
        pdg_update_is_neg <= (divA_in(31) xor (divB_in(31) and is_divs));
      else
        divA_loc := divA_in;
        divB_loc := divB_in;
        pdg_we_is_neg <= '1';
        pdg_update_is_neg <= Cuint1_t_0;
      end if;
      pdg_we_PA <= '1';
      pdg_update_PA <= resize(unsigned(divA_loc), 64);
      pdg_we_B <= '1';
      pdg_update_B <= unsigned(divB_loc);
      pdg_we_Q_addr_reg <= '1';
      pdg_update_Q_addr_reg <= div_wad_in;
      pdg_we_is_div <= '1';
      pdg_update_is_div <= (is_divs or is_divu);
      pdg_we_cnt <= '1';
      pdg_update_cnt <= Cuint6_t_33;
    else
      if ((cnt > Cuint6_t_1)) then
        new_pa := shift_left(PA, 1);
        diff := (resize(new_pa(63 downto 32), 33) - resize(B, 33));
        if ((diff(32) = Cuint1_t_0)) then
          new_pa(63 downto 32) := resize(diff, 32);
          new_pa(0) := Cuint1_t_1;
        end if;
        div_step_result := new_pa;
        pdg_we_PA <= '1';
        pdg_update_PA <= div_step_result;
        pdg_we_cnt <= '1';
        pdg_update_cnt <= (cnt - Cuint6_t_1);
      else
        if ((cnt = Cuint6_t_1)) then
          pa_0 := PA;
          if (std_logic_to_boolean(is_div)) then
            t := pa_0(31 downto 0);
          else
            t := pa_0(63 downto 32);
          end if;
          res := signed(t);
          if (std_logic_to_boolean(is_neg)) then
            res := (-res);
          end if;
          if (((B = Cuint32_t_0) and std_logic_to_boolean(is_div))) then
            res := Cint32_t_m1;
          end if;
          X_x_w1_div_main_pdg_w_a_out <= Q_addr_reg;
          X_x_w1_div_main_pdg_en_out <= Cuint1_t_1;
          x_w1_out <= res;
          pdg_we_cnt <= '1';
          pdg_update_cnt <= (cnt - Cuint6_t_1);
        end if;
      end if;
    end if;
  end process p_main;

  p_state_to_core : process(Q_addr_reg,
                            cnt)
    constant Cuint6_t_0 : unsigned(5 downto 0) := (others => '0');
    constant Cuint6_t_2 : unsigned(5 downto 0) := "000010";
  begin
    div_adr_out <= (others => '0');
    div_bsy_out <= '0';
    div_wnc_out <= '0';
    div_bsy_out <= boolean_to_std_logic(cnt /= Cuint6_t_0);
    div_adr_out <= Q_addr_reg;
    div_wnc_out <= boolean_to_std_logic(cnt = Cuint6_t_2);
  end process p_state_to_core;


  p_update_status : process(clock, reset)
  begin
    if reset /= '0' then
      B <= (others => '0');
      PA <= (others => '0');
      Q_addr_reg <= (others => '0');
      cnt <= (others => '0');
      is_div <= '0';
      is_neg <= '0';
    elsif clock'event and clock = '1' then
      if pdg_we_B = '1' then
        B <= pdg_update_B;
      end if;
      if pdg_we_PA = '1' then
        PA <= pdg_update_PA;
      end if;
      if pdg_we_Q_addr_reg = '1' then
        Q_addr_reg <= pdg_update_Q_addr_reg;
      end if;
      if pdg_we_cnt = '1' then
        cnt <= pdg_update_cnt;
      end if;
      if pdg_we_is_div = '1' then
        is_div <= pdg_update_is_div;
      end if;
      if pdg_we_is_neg = '1' then
        is_neg <= pdg_update_is_neg;
      end if;
    end if;
  end process p_update_status;
end rtl;
