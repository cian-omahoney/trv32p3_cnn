
-- File generated by Go version U-2022.12#33f3808fcb#221128, Wed Feb 21 13:01:39 2024
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- go -I../lib -F -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 -VHDL -otrv32p3_cnn_vhdl -cgo_options.cfg -Itrv32p3_cnn_vhdl/tmp_pdg -updg -updg_controller trv32p3_cnn



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- synopsys translate_off
use std.textio.all;
use ieee.std_logic_textio.all;
-- synopsys translate_on
package data_types is
  subtype t_uint1_t is std_logic;
  subtype t_uint1_t_array is std_logic_vector;

  subtype t_t1u is std_logic;
  subtype t_t1u_array is std_logic_vector;

  subtype t_t2u is unsigned (1 downto 0);

  subtype t_uint4_t_as_vect is unsigned (3 downto 0);

  subtype t_t5unz is unsigned (4 downto 0);

  subtype t_t5u is unsigned (4 downto 0);

  subtype t_jtag_coreid_tp is unsigned (4 downto 0);

  subtype t_t6u is unsigned (5 downto 0);

  subtype t_uint8_t is unsigned (7 downto 0);
  type t_uint8_t_array is array (natural range <>) of t_uint8_t;

  subtype t_u08 is unsigned (7 downto 0);
  type t_u08_array is array (natural range <>) of t_u08;

  subtype t_t8u is unsigned (7 downto 0);

  subtype t_w08 is signed (7 downto 0);
  type t_w08_array is array (natural range <>) of t_w08;

  subtype t_jtag_opcode_tp is std_logic_vector(10 downto 0);

  subtype t_t12s is signed (11 downto 0);

  subtype t_t13s_s2 is signed (12 downto 0);

  subtype t_w16 is signed (15 downto 0);
  type t_w16_array is array (natural range <>) of t_w16;

  subtype t_jtag_status_tp is std_logic_vector(15 downto 0);

  subtype t_jtag_instr_tp is std_logic_vector(15 downto 0);

  subtype t_t20s_rp12 is signed (19 downto 0);

  subtype t_t21s_s2 is signed (20 downto 0);

  subtype t_t31s_rp1 is signed (30 downto 0);

  subtype t_v4u8 is unsigned (31 downto 0);
  type t_v4u8_array is array (natural range <>) of t_v4u8;

  subtype t_iword is unsigned (31 downto 0);
  type t_iword_array is array (natural range <>) of t_iword;

  subtype t_controller_v4uint8_t is unsigned (31 downto 0);

  subtype t_addr is unsigned (31 downto 0);

  subtype t_w32 is signed (31 downto 0);
  type t_w32_array is array (natural range <>) of t_w32;

  subtype t_w64 is signed (63 downto 0);

  function or_reduce (constant arg : std_logic_vector)
    return std_logic;

  function to_integer (constant arg : std_logic)
    return integer;

  function std_logic_to_boolean (constant arg : std_logic)
    return boolean;

  function boolean_to_std_logic (constant arg : boolean)
    return std_logic;

  function std_logic_to_boolean (constant arg : unsigned)
    return boolean;

  function std_logic_to_boolean (constant arg : signed)
    return boolean;

  function bool_to_unsigned(x : boolean)
    return unsigned;

  function bool_to_signed(x : boolean)
    return signed;

  function unsigned_to_bool(x : unsigned)
    return boolean;

  function signed_to_bool(x : signed)
    return boolean;

  function integer_to_bool(x : integer)
    return boolean;

  function std_logic_to_unsigned(x : std_logic)
    return unsigned;

  function std_logic_to_signed(x : std_logic)
    return signed;

  function unsigned_to_std_logic(x : unsigned)
    return std_logic;

  function signed_to_std_logic(x : signed)
    return std_logic;

  function controller_v4uint8_t_extract_element (v : t_controller_v4uint8_t;
                                                 i : integer)
    return t_uint8_t;

  function controller_v4uint8_t_insert_element (v : t_controller_v4uint8_t;
                                                i : integer;
                                                e : t_uint8_t)
    return t_controller_v4uint8_t;

  function uint4_t_as_vect_extract_element (v : t_uint4_t_as_vect;
                                            i : integer)
    return t_uint1_t;

  function uint4_t_as_vect_insert_element (v : t_uint4_t_as_vect;
                                           i : integer;
                                           e : t_uint1_t)
    return t_uint4_t_as_vect;

  function v4u8_extract_element (v : t_v4u8;
                                 i : integer)
    return t_u08;

  function v4u8_insert_element (v : t_v4u8;
                                i : integer;
                                e : t_u08)
    return t_v4u8;

  -- synopsys translate_off
  function to_string(x : std_logic)
    return string;

  function to_string(x : signed)
    return string;

  function to_string(x : unsigned)
    return string;

  function to_hex_string(x : std_logic)
    return string;

  function to_hex_string(x : signed)
    return string;

  function to_hex_string(x : unsigned)
    return string;

  function to_oct_string(x : std_logic)
    return string;

  function to_oct_string(x : signed)
    return string;

  function to_oct_string(x : unsigned)
    return string;

  function to_dec_string(constant val : unsigned)
    return string;

  -- synopsys translate_on

  -- synopsys translate_off
  procedure renew_logfile(rcd_valid: out boolean);
  procedure logfile_write(L: inout LINE);
  signal rcd_valid: boolean := false;
  -- synopsys translate_on

end data_types;



package body data_types is

  function or_reduce (constant arg : std_logic_vector)
    return std_logic is
    variable result : std_logic;
  begin
    result := '0';
    for i in arg'range loop
      result := result or arg(i);
    end loop;
    return result;
  end or_reduce;

  function to_integer (constant arg : std_logic)
    return integer is
  begin
    if arg = '1' then
      return 1;
    else
      return 0;
    end if;
  end to_integer;

  function std_logic_to_boolean (constant arg : std_logic)
    return boolean is
  begin
    if arg = '1' then
      return true;
    else
      return false;
    end if;
  end std_logic_to_boolean;

  function boolean_to_std_logic (constant arg : boolean)
    return std_logic is
  begin
    if arg then
      return '1';
    else
      return '0';
    end if;
  end boolean_to_std_logic;

  function std_logic_to_boolean (constant arg : unsigned)
    return boolean is
  begin
    if arg /= 0 then
      return true;
    else
      return false;
    end if;
  end std_logic_to_boolean;

  function std_logic_to_boolean (constant arg : signed)
    return boolean is
  begin
    if arg /= 0 then
      return true;
    else
      return false;
    end if;
  end std_logic_to_boolean;

  function bool_to_unsigned(x : boolean)
    return unsigned is
  begin
    if x then return "1"; else return "0"; end if;
  end bool_to_unsigned;

  function bool_to_signed(x : boolean)
    return signed is
  begin
    if x then return "1"; else return "0"; end if;
  end bool_to_signed;

  function unsigned_to_bool(x : unsigned)
    return boolean is
  begin
    return x /= 0;
  end unsigned_to_bool;

  function signed_to_bool(x : signed)
    return boolean is
  begin
    return x /= 0;
  end signed_to_bool;

  function integer_to_bool(x : integer)
    return boolean is
  begin
    return x /= 0;
  end integer_to_bool;

  function std_logic_to_unsigned(x : std_logic)
    return unsigned is
    variable t : unsigned(0 downto 0);
  begin
    t(0) := x; return t;
  end std_logic_to_unsigned;

  function std_logic_to_signed(x : std_logic)
    return signed is
    variable t : signed(0 downto 0);
  begin
    t(0) := x; return t;
  end std_logic_to_signed;

  function unsigned_to_std_logic(x : unsigned)
    return std_logic is
  begin
    if x = 0 then
      return '0';
    else
      return '1';
    end if;
  end unsigned_to_std_logic;

  function signed_to_std_logic(x : signed)
    return std_logic is
  begin
    if x = 0 then
      return '0';
    else
      return '1';
    end if;
  end signed_to_std_logic;

  function controller_v4uint8_t_extract_element (v : t_controller_v4uint8_t;
                                                 i : integer)
    return t_uint8_t is
    variable ii : integer range 0 to 3;
    variable iii : integer;
    variable vi : natural range 0 to 31;
    variable result : t_uint8_t;
  begin
    iii := i;
    -- synopsys translate_off
    if i < 0 or i > 3 then
      iii := 0;
    end if;
    -- synopsys translate_on
    ii := iii;
    for ei in 7 downto 0 loop
      vi := ii * 8 + ei;
      result(ei) := v(vi);
    end loop;
    return result;
  end controller_v4uint8_t_extract_element;

  function controller_v4uint8_t_insert_element (v : t_controller_v4uint8_t;
                                                i : integer;
                                                e : t_uint8_t)
    return t_controller_v4uint8_t is
    variable ii : integer range 0 to 3;
    variable iii : integer;
    variable vi : natural range 0 to 31;
    variable result : t_controller_v4uint8_t;
  begin
    iii := i;
    -- synopsys translate_off
    if i < 0 or i > 3 then
      iii := 0;
    end if;
    -- synopsys translate_on
    ii := iii;
    result := v;
    for ei in 7 downto 0 loop
      vi := ii * 8 + ei;
      result(vi) := e(ei);
    end loop;
    return result;
  end controller_v4uint8_t_insert_element;

  function uint4_t_as_vect_extract_element (v : t_uint4_t_as_vect;
                                            i : integer)
    return t_uint1_t is
    variable ii : integer range 0 to 3;
    variable iii : integer;
    variable vi : natural range 0 to 3;
    variable result : t_uint1_t;
  begin
    iii := i;
    -- synopsys translate_off
    if i < 0 or i > 3 then
      iii := 0;
    end if;
    -- synopsys translate_on
    ii := iii;
    for ei in 0 downto 0 loop
      vi := ii * 1 + ei;
      result := v(vi);
    end loop;
    return result;
  end uint4_t_as_vect_extract_element;

  function uint4_t_as_vect_insert_element (v : t_uint4_t_as_vect;
                                           i : integer;
                                           e : t_uint1_t)
    return t_uint4_t_as_vect is
    variable ii : integer range 0 to 3;
    variable iii : integer;
    variable vi : natural range 0 to 3;
    variable result : t_uint4_t_as_vect;
  begin
    iii := i;
    -- synopsys translate_off
    if i < 0 or i > 3 then
      iii := 0;
    end if;
    -- synopsys translate_on
    ii := iii;
    result := v;
    for ei in 0 downto 0 loop
      vi := ii * 1 + ei;
      result(vi) := e;
    end loop;
    return result;
  end uint4_t_as_vect_insert_element;

  function v4u8_extract_element (v : t_v4u8;
                                 i : integer)
    return t_u08 is
    variable ii : integer range 0 to 3;
    variable iii : integer;
    variable vi : natural range 0 to 31;
    variable result : t_u08;
  begin
    iii := i;
    -- synopsys translate_off
    if i < 0 or i > 3 then
      iii := 0;
    end if;
    -- synopsys translate_on
    ii := iii;
    for ei in 7 downto 0 loop
      vi := ii * 8 + ei;
      result(ei) := v(vi);
    end loop;
    return result;
  end v4u8_extract_element;

  function v4u8_insert_element (v : t_v4u8;
                                i : integer;
                                e : t_u08)
    return t_v4u8 is
    variable ii : integer range 0 to 3;
    variable iii : integer;
    variable vi : natural range 0 to 31;
    variable result : t_v4u8;
  begin
    iii := i;
    -- synopsys translate_off
    if i < 0 or i > 3 then
      iii := 0;
    end if;
    -- synopsys translate_on
    ii := iii;
    result := v;
    for ei in 7 downto 0 loop
      vi := ii * 8 + ei;
      result(vi) := e(ei);
    end loop;
    return result;
  end v4u8_insert_element;

  -- synopsys translate_off
  function to_string(x : std_logic)
    return string is
  begin
    if x = '1' then
      return "1";
    else
      return "0";
    end if;
  end to_string;

  function to_string(x : signed)
    return string is
    variable ln: line;
  begin
    write(ln, to_integer(x));
    return ln.all;
  end to_string;

  function to_string(x : unsigned)
    return string is
    variable ln: line;
  begin
    write(ln, to_integer(x));
    return ln.all;
  end to_string;

  function to_hex_string(x : std_logic)
    return string is
  begin
    if x = '1' then
      return "1";
    else
      return "0";
    end if;
  end to_hex_string;

  function to_hex_string(x : signed)
    return string is
    variable ln: line;
  begin
    hwrite(ln, std_logic_vector(x));
    return ln.all;
  end to_hex_string;

  function to_hex_string(x : unsigned)
    return string is
    variable ln: line;
  begin
    hwrite(ln, std_logic_vector(x));
    return ln.all;
  end to_hex_string;

  function to_oct_string(x : std_logic)
    return string is
  begin
    if x = '1' then
      return "1";
    else
      return "0";
    end if;
  end to_oct_string;

  function to_oct_string(x : signed)
    return string is
    variable ln: line;
  begin
    owrite(ln, std_logic_vector(x));
    return ln.all;
  end to_oct_string;

  function to_oct_string(x : unsigned)
    return string is
    variable ln: line;
  begin
    owrite(ln, std_logic_vector(x));
    return ln.all;
  end to_oct_string;

  function to_dec_string ( constant val : unsigned) return string is

    function divide_by_10 ( constant n : unsigned) return unsigned is
      variable r, q : unsigned(n'length - 1 downto 0);
    begin
      q := (others => '0');
      r := (others => '0');
      for i in integer(n'length) - 1 downto 0 loop
        r := r sll 1;
        r(0) := n(i);
        if r >= 10 then
          r := r - 10;
          q(i) := '1';
        end if;
      end loop;
      return q;
    end function divide_by_10;

    variable ret_val : string(1 to integer(0.302*real(val'length) + 1.0));
    variable index : integer := ret_val'right;
    variable last_digit, quotient : unsigned(val'length - 1 downto 0);
  begin
    if is_x(std_logic_vector(val)) then
      return "NaN";
    end if;

    if val = (val'range => '0') then
      return "0";
    end if;

    if val'length < 32 then
      return integer'image(to_integer(val));
    end if;

    quotient := val;
    while quotient /= (quotient'range => '0') loop
      last_digit := quotient mod 10;
      quotient := divide_by_10(quotient);
      ret_val(index to index) := integer'image(to_integer(last_digit(3 downto 0)));
      index := index - 1;
    end loop;

    return ret_val(index + 1 to ret_val'right);
  end function to_dec_string;

  -- synopsys translate_on

  -- synopsys translate_off

  file reg_log_file : text;
  file rcdname_file : text;

  procedure fstring_read(file in_file: text; res_string: out string; len : out integer) is
    variable l:         line;
    variable c:         character;
    variable is_string: boolean;
  begin
    readline(in_file, l);
    -- clear the contents of the result string
    for i in res_string'range loop
      res_string(i) := ' ';
    end loop;
    -- read all characters of the line, up to the length  
    -- of the results string
    for i in res_string'range loop
      read(l, c, is_string);
      res_string(i) := c;
      if not is_string then -- found end of line
        len := i-1;
        return;
      end if;
    end loop;
    len := res_string'high;
  end fstring_read;

  procedure renew_logfile (rcd_valid: out boolean) is
    variable rcdname_fstatus : FILE_OPEN_STATUS;
    variable rcd_fname       : string(1 to 255);
    variable rcd_fstatus     : FILE_OPEN_STATUS;
    variable len             : integer;
    variable rtline          : line;
    variable rline           : line;
  begin
    write(rtline, string'("reset_type: async, act_high"));
    write(rline, string'("reset at "));
    write(rline, now);
    file_close(reg_log_file);
    rcd_valid := false;
    -- get the rcd file name from a file, if exists:
    file_open(rcdname_fstatus, rcdname_file, "rcdname.cfg", read_mode);
    if (rcdname_fstatus = OPEN_OK) then
      if (not endfile(rcdname_file)) then
        fstring_read(rcdname_file, rcd_fname, len);
        file_close(rcdname_file);
        if (rcd_fname'length > 0) then
          file_open(rcd_fstatus, reg_log_file, rcd_fname(1 to len), write_mode);
        else
          file_open(rcd_fstatus, reg_log_file, "register.log", write_mode);
        end if;
        if (rcd_fstatus = OPEN_OK) then
          rcd_valid := true;
          writeline(reg_log_file, rtline);
          writeline(reg_log_file, rline);
        end if;
        return;
      end if;
    end if;
    file_open(rcd_fstatus, reg_log_file, "register.log", write_mode);
    if (rcd_fstatus = OPEN_OK) then
      rcd_valid := true;
      writeline(reg_log_file, rtline);
      writeline(reg_log_file, rline);
    end if;
  end renew_logfile;

  procedure logfile_write(L: inout LINE) is
  begin
    if (rcd_valid) then
      writeline(reg_log_file, L);
    end if;
  end logfile_write;

  -- synopsys translate_on

end data_types;

