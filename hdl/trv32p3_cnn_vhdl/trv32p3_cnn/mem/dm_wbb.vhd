
-- File generated by Go version U-2022.12#33f3808fcb#221128, Wed Feb 21 17:37:19 2024
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- go -I../lib -F -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 -VHDL -otrv32p3_cnn_vhdl -cgo_options.cfg -Itrv32p3_cnn_vhdl/tmp_pdg -updg -updg_controller trv32p3_cnn




-- File generated by pdg version U-2022.12#33f3808fcb#221128
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- pdg -I../lib -D__go__ -VHDL -cgo_options.cfg -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 +wtrv32p3_cnn_vhdl/tmp_pdg trv32p3_cnn


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library trv32p3_cnn_lib;
use trv32p3_cnn_lib.data_types.all;

entity dm_wbb is
  port (
    reset : in std_logic;
    clock : in std_logic;
    edm_rd_in : in t_v4u8;
    wdm_ld_in : in std_logic;
    wdm_addr_in : in t_addr;
    wdm_wr_in : in t_v4u8;
    wdm_st_in : in t_uint4_t_as_vect;
    wdm_rd_out : out t_v4u8;
    edm_ld_out : out std_logic;
    edm_addr_out : out t_addr;
    edm_st_out : out t_uint4_t_as_vect;
    edm_wr_out : out t_v4u8);
end dm_wbb;

architecture rtl of dm_wbb is
  signal edm_addr_ff : unsigned(31 downto 0);
  signal pdg_update_edm_addr_ff : unsigned(31 downto 0);
  signal pdg_we_edm_addr_ff : std_logic;
  signal edm_addr_match_ff : std_logic;
  signal pdg_update_edm_addr_match_ff : std_logic;
  signal pdg_we_edm_addr_match_ff : std_logic;
  signal edm_data_ff : unsigned(31 downto 0);
  signal pdg_update_edm_data_ff : unsigned(31 downto 0);
  signal pdg_we_edm_data_ff : std_logic;
  signal edm_st_ff : std_logic;
  signal pdg_update_edm_st_ff : std_logic;
  signal pdg_we_edm_st_ff : std_logic;
  signal edm_strb_ff : unsigned(3 downto 0);
  signal pdg_update_edm_strb_ff : unsigned(3 downto 0);
  signal pdg_we_edm_strb_ff : std_logic;
  signal edm_wbb_ff : std_logic;
  signal pdg_update_edm_wbb_ff : std_logic;
  signal pdg_we_edm_wbb_ff : std_logic;
begin
  p_process_result : process(edm_addr_match_ff,
                             edm_data_ff,
                             edm_rd_in,
                             edm_strb_ff,
                             edm_wbb_ff)
    variable byp : boolean;
    variable sel : unsigned(1 downto 0);
    variable sel_0 : unsigned(2 downto 0);
    variable sel_1 : unsigned(3 downto 0);
    variable sel_2 : unsigned(3 downto 0);
    variable t : unsigned(7 downto 0);
    variable t_0 : unsigned(31 downto 0);
    variable t_1 : unsigned(7 downto 0);
    variable t_2 : unsigned(31 downto 0);
    variable t_3 : unsigned(7 downto 0);
    variable t_4 : unsigned(31 downto 0);
    variable t_5 : unsigned(7 downto 0);
    variable t_6 : unsigned(31 downto 0);
    variable tmp : unsigned(15 downto 0);
    variable tmp_0 : unsigned(23 downto 0);
    variable tmp_1 : unsigned(31 downto 0);
    constant Cuint1_t_0 : std_logic := '0';
    constant Cuint2_t_3 : unsigned(1 downto 0) := "11";
    constant Cuint2_t_2 : unsigned(1 downto 0) := "10";
    constant Cuint1_t_1 : std_logic := '1';
  begin
    t := (others => '0');
    t_0 := (others => '0');
    t_1 := (others => '0');
    t_2 := (others => '0');
    t_3 := (others => '0');
    t_4 := (others => '0');
    t_5 := (others => '0');
    t_6 := (others => '0');
    wdm_rd_out <= (others => '0');
    byp := (std_logic_to_boolean(edm_wbb_ff) and std_logic_to_boolean(edm_addr_match_ff));
    sel := std_logic_to_unsigned(boolean_to_std_logic(byp)) & std_logic_to_unsigned(boolean_to_std_logic(byp));
    sel_0 := sel & std_logic_to_unsigned(boolean_to_std_logic(byp));
    sel_1 := sel_0 & std_logic_to_unsigned(boolean_to_std_logic(byp));
    sel_2 := (edm_strb_ff and sel_1);
    if ((sel_2(3) = Cuint1_t_0)) then
      t := edm_rd_in(31 downto 24);
    else
      t_0 := edm_data_ff;
      t := t_0(31 downto 24);
    end if;
    if ((sel_2(2) = Cuint1_t_0)) then
      t_1 := edm_rd_in(23 downto 16);
    else
      t_2 := edm_data_ff;
      t_1 := t_2(23 downto 16);
    end if;
    if ((sel_2(1) = Cuint1_t_0)) then
      t_3 := edm_rd_in(15 downto 8);
    else
      t_4 := edm_data_ff;
      t_3 := t_4(15 downto 8);
    end if;
    if ((sel_2(0) = Cuint1_t_0)) then
      t_5 := edm_rd_in(7 downto 0);
    else
      t_6 := edm_data_ff;
      t_5 := t_6(7 downto 0);
    end if;
    tmp := t & t_1;
    tmp_0 := tmp & t_3;
    tmp_1 := tmp_0 & t_5;
    wdm_rd_out <= tmp_1;
  end process p_process_result;

  p_process_request : process(edm_addr_ff,
                              edm_data_ff,
                              edm_st_ff,
                              edm_strb_ff,
                              edm_wbb_ff,
                              wdm_addr_in,
                              wdm_ld_in,
                              wdm_st_in,
                              wdm_wr_in)
    variable L0 : std_logic;
    variable L0_0 : unsigned(3 downto 0);
    constant Cuint1_t_0 : std_logic := '0';
    constant Cuint1_t_1 : std_logic := '1';
    constant Cuint4_t_0 : unsigned(3 downto 0) := (others => '0');
  begin
    edm_addr_out <= (others => '0');
    pdg_we_edm_addr_ff <= '0';
    pdg_update_edm_addr_ff <= (others => '0');
    pdg_we_edm_addr_match_ff <= '0';
    pdg_update_edm_addr_match_ff <= '0';
    pdg_we_edm_data_ff <= '0';
    pdg_update_edm_data_ff <= (others => '0');
    edm_ld_out <= '0';
    edm_st_out <= (others => '0');
    pdg_we_edm_st_ff <= '0';
    pdg_update_edm_st_ff <= '0';
    pdg_we_edm_strb_ff <= '0';
    pdg_update_edm_strb_ff <= (others => '0');
    pdg_we_edm_wbb_ff <= '0';
    pdg_update_edm_wbb_ff <= '0';
    edm_wr_out <= (others => '0');
    edm_ld_out <= wdm_ld_in;
    if (std_logic_to_boolean(wdm_ld_in)) then
      edm_addr_out <= wdm_addr_in;
      pdg_we_edm_addr_match_ff <= '1';
      pdg_update_edm_addr_match_ff <= boolean_to_std_logic(wdm_addr_in = edm_addr_ff);
    end if;
    L0 := Cuint1_t_0;
    for pdg_it in 0 to 3 loop
      L0_0(pdg_it) := L0;
    end loop;
    edm_st_out <= L0_0;
    if (std_logic_to_boolean(wdm_ld_in)) then
      if (std_logic_to_boolean(edm_st_ff)) then
        pdg_we_edm_data_ff <= '1';
        pdg_update_edm_data_ff <= wdm_wr_in;
        pdg_we_edm_wbb_ff <= '1';
        pdg_update_edm_wbb_ff <= Cuint1_t_1;
      end if;
    else
      if (std_logic_to_boolean(edm_wbb_ff)) then
        edm_st_out <= edm_strb_ff;
        edm_addr_out <= edm_addr_ff;
        edm_wr_out <= edm_data_ff;
        pdg_we_edm_wbb_ff <= '1';
        pdg_update_edm_wbb_ff <= Cuint1_t_0;
      else
        if (std_logic_to_boolean(edm_st_ff)) then
          edm_st_out <= edm_strb_ff;
          edm_addr_out <= edm_addr_ff;
          edm_wr_out <= wdm_wr_in;
        end if;
      end if;
      if ((wdm_st_in /= Cuint4_t_0)) then
        pdg_we_edm_addr_ff <= '1';
        pdg_update_edm_addr_ff <= wdm_addr_in;
        pdg_we_edm_strb_ff <= '1';
        pdg_update_edm_strb_ff <= wdm_st_in;
      end if;
    end if;
    pdg_we_edm_st_ff <= '1';
    pdg_update_edm_st_ff <= boolean_to_std_logic(wdm_st_in /= Cuint4_t_0);
  end process p_process_request;


  p_update_status : process(clock, reset)
  begin
    if reset /= '0' then
      edm_addr_ff <= (others => '0');
      edm_addr_match_ff <= '0';
      edm_data_ff <= (others => '0');
      edm_st_ff <= '0';
      edm_strb_ff <= (others => '0');
      edm_wbb_ff <= '0';
    elsif clock'event and clock = '1' then
      if pdg_we_edm_addr_ff = '1' then
        edm_addr_ff <= pdg_update_edm_addr_ff;
      end if;
      if pdg_we_edm_addr_match_ff = '1' then
        edm_addr_match_ff <= pdg_update_edm_addr_match_ff;
      end if;
      if pdg_we_edm_data_ff = '1' then
        edm_data_ff <= pdg_update_edm_data_ff;
      end if;
      if pdg_we_edm_st_ff = '1' then
        edm_st_ff <= pdg_update_edm_st_ff;
      end if;
      if pdg_we_edm_strb_ff = '1' then
        edm_strb_ff <= pdg_update_edm_strb_ff;
      end if;
      if pdg_we_edm_wbb_ff = '1' then
        edm_wbb_ff <= pdg_update_edm_wbb_ff;
      end if;
    end if;
  end process p_update_status;
end rtl;
