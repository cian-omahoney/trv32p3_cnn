
-- File generated by Go version U-2022.12#33f3808fcb#221128, Wed Feb 21 17:37:19 2024
-- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
-- go -I../lib -F -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 -VHDL -otrv32p3_cnn_vhdl -cgo_options.cfg -Itrv32p3_cnn_vhdl/tmp_pdg -updg -updg_controller trv32p3_cnn



architecture rtl of controller is
  signal en_vd_br_cnd_of13_cd_EX : boolean;
  signal en_lnk_id_jal_of21_ID : boolean;
  signal en_lnk_id_jalr_trgt_ID : boolean;

  signal en_jump_of13_cd_sig : boolean;
  signal en_jump_of21_sig : boolean;
  signal en_jump_trgt_sig : boolean;


  -- File generated by pdg version U-2022.12#33f3808fcb#221128
  -- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
  -- pdg -I../lib -D__go__ -pcu -VHDL -cgo_options.cfg -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 +wtrv32p3_cnn_vhdl/tmp_pdg trv32p3_cnn


  -- Controller specific registers and transitories.
  signal r_booting : std_logic;
  signal pdg_update_r_booting : std_logic;
  signal pdg_we_r_booting : std_logic;
  signal r_fetched : std_logic;
  signal pdg_update_r_fetched : std_logic;
  signal pdg_we_r_fetched : std_logic;
  signal r_state : unsigned(3 downto 0);
  signal pdg_update_r_state : unsigned(3 downto 0);
  signal pdg_we_r_state : std_logic;
  signal t_stop_issue : std_logic;
begin

  en_vd_br_cnd_of13_cd_EX <= ohe_selector_EX = '1';
  en_lnk_id_jal_of21_ID <= bin_selector_ID = "01";
  en_lnk_id_jalr_trgt_ID <= bin_selector_ID = "10";

  en_jump_of13_cd_sig <= (en_vd_br_cnd_of13_cd_EX and cnd_in);
  en_jump_of21_sig <= en_lnk_id_jal_of21_ID;
  en_jump_trgt_sig <= en_lnk_id_jalr_trgt_ID;


  -- File generated by pdg version U-2022.12#33f3808fcb#221128
  -- Copyright 2014-2022 Synopsys, Inc. All rights reserved.
  -- pdg -I../lib -D__go__ -pcu -VHDL -cgo_options.cfg -DIS_VHDL -DSYNTHESIS_NO_UNGROUP -D__tct_patch__=0 +wtrv32p3_cnn_vhdl/tmp_pdg trv32p3_cnn




  user_issue : process(en_jump_of13_cd_sig,
                       hzd_stall_in,
                       issue_sig_in,
                       ocd_exe_in,
                       ocd_instr_r_in,
                       ocd_req_in,
                       pcr_in,
                       pm_rd_in,
                       r_booting,
                       r_fetched,
                       r_state)
    variable PC_IF_l : unsigned(31 downto 0);
    variable br_EX : boolean;
    variable flush_IF : boolean;
    variable flush_ID : boolean;
    variable could_issue : boolean;
    variable ii : unsigned(31 downto 0);
    variable instr_avail : boolean;
    variable interruptible : boolean;
    variable ocd_req_int : boolean;
    variable stop_issue : boolean;
    variable ii_0 : unsigned(31 downto 0);
    variable issue_ins : boolean;
    constant Cuint4_t_0 : unsigned(3 downto 0) := (others => '0');
    constant Cuint4_t_15 : unsigned(3 downto 0) := "1111";
    constant Cuint4_t_14 : unsigned(3 downto 0) := "1110";
    constant Cuint4_t_12 : unsigned(3 downto 0) := "1100";
    constant Cuint4_t_8 : unsigned(3 downto 0) := "1000";
    constant Caddr_0 : unsigned(31 downto 0) := (others => '0');
    constant Cuint1_t_0 : std_logic := '0';
    constant Cuint1_t_1 : std_logic := '1';
    constant Cuint2_t_2 : unsigned(1 downto 0) := "10";
    constant Cuint2_t_3 : unsigned(1 downto 0) := "11";
  begin
    trn_ID_valid_out <= '0';
    trn_IR_ID_out <= (others => '0');
    kill_ID_out <= '0';
    PC_ID_PC_ID_w_cntrl_issue_pdg_en_out <= '0';
    PC_ID_w_out <= (others => '0');
    ii_0 := (others => '0');
    lnk_id_out <= (others => '0');
    ocd_mode_out <= '0';
    pdg_we_r_booting <= '0';
    pdg_update_r_booting <= '0';
    pdg_we_r_state <= '0';
    pdg_update_r_state <= (others => '0');
    t_stop_issue <= '0';
    PC_IF_l := pcr_in;
    lnk_id_out <= signed(PC_IF_l);
    br_EX := en_jump_of13_cd_sig;
    flush_IF := br_EX;
    flush_ID := br_EX;
    if (flush_ID) then
      kill_ID_out <= '1';
    end if;
    could_issue := (std_logic_to_boolean(issue_sig_in) and (not (std_logic_to_boolean(hzd_stall_in) and (not flush_ID))));
    ii := pm_rd_in;
    instr_avail := std_logic_to_boolean(r_fetched);
    interruptible := could_issue;
    ocd_req_int := (std_logic_to_boolean(ocd_req_in) and interruptible);
    if ((r_state = Cuint4_t_0)) then
      if (ocd_req_int) then
        pdg_we_r_state <= '1';
        pdg_update_r_state <= Cuint4_t_15;
      end if;
    else
      if ((r_state = Cuint4_t_15)) then
        if ((not std_logic_to_boolean(ocd_req_in))) then
          pdg_we_r_state <= '1';
          pdg_update_r_state <= Cuint4_t_14;
        end if;
      else
        if ((r_state = Cuint4_t_14)) then
          pdg_we_r_state <= '1';
          pdg_update_r_state <= Cuint4_t_12;
        else
          if ((r_state = Cuint4_t_12)) then
            if (instr_avail) then
              pdg_we_r_state <= '1';
              pdg_update_r_state <= Cuint4_t_8;
            end if;
          else
            if ((r_state = Cuint4_t_8)) then
              pdg_we_r_state <= '1';
              pdg_update_r_state <= Cuint4_t_0;
            end if;
          end if;
        end if;
      end if;
    end if;
    stop_issue := (((((r_state = Cuint4_t_0) and ocd_req_int) or (r_state = Cuint4_t_15)) or (r_state = Cuint4_t_14)) or (r_state = Cuint4_t_12));
    ocd_mode_out <= ((boolean_to_std_logic(r_state = Cuint4_t_15) or boolean_to_std_logic(r_state = Cuint4_t_14)) or boolean_to_std_logic(r_state = Cuint4_t_12));
    if (std_logic_to_boolean(ocd_exe_in)) then
      ii_0 := ocd_instr_r_in;
      trn_ID_valid_out <= '1';
      trn_IR_ID_out(31 downto 24) <= ii_0(31 downto 24);
      trn_IR_ID_out(23 downto 16) <= ii_0(23 downto 16);
      trn_IR_ID_out(15 downto 8) <= ii_0(15 downto 8);
      trn_IR_ID_out(7 downto 0) <= ii_0(7 downto 0);
    end if;
    issue_ins := (((instr_avail and (not flush_IF)) and could_issue) and (not stop_issue));
    if (issue_ins) then
      trn_ID_valid_out <= '1';
      trn_IR_ID_out(31 downto 24) <= ii(31 downto 24);
      trn_IR_ID_out(23 downto 16) <= ii(23 downto 16);
      trn_IR_ID_out(15 downto 8) <= ii(15 downto 8);
      trn_IR_ID_out(7 downto 0) <= ii(7 downto 0);
      PC_ID_PC_ID_w_cntrl_issue_pdg_en_out <= Cuint1_t_1;
      PC_ID_w_out <= PC_IF_l;
    else
    end if;
    if (std_logic_to_boolean(r_booting)) then
      pdg_we_r_booting <= '1';
      pdg_update_r_booting <= Cuint1_t_0;
    end if;
    t_stop_issue <= boolean_to_std_logic(stop_issue);
  end process user_issue;


  user_next_pc : process(en_jump_of13_cd_sig,
                         en_jump_of21_sig,
                         en_jump_trgt_sig,
                         hzd_stall_in,
                         issue_sig_in,
                         jmp_tgt_EX_in,
                         jmp_tgt_ID_in,
                         pcr_in,
                         r_fetched,
                         r_state,
                         t_stop_issue
                         -- synopsys translate_off
                         ,  clock
                         -- synopsys translate_on
                       )
    variable PC_IF_l : unsigned(31 downto 0);
    variable br_EX : boolean;
    variable jalr_ID : boolean;
    variable jal_ID : boolean;
    variable incr_pc : unsigned(31 downto 0);
    variable leave_dbg : boolean;
    variable jump_pc : unsigned(31 downto 0);
    variable jump : boolean;
    variable t : unsigned(31 downto 0);
    variable next_pc : unsigned(31 downto 0);
    variable could_issue : boolean;
    variable could_jump : boolean;
    variable instr_avail : boolean;
    variable update_pc : boolean;
    variable ocd_issue_stall : boolean;
    variable fetch_next : boolean;
    variable t_0 : unsigned(31 downto 0);
    variable fetch_pc : unsigned(31 downto 0);
    variable fetch : boolean;
    constant Cuint8_t_1 : unsigned(7 downto 0) := "00000001";
    constant Cuint32_t_4 : unsigned(31 downto 0) := "00000000000000000000000000000100";
    constant Cuint4_t_14 : unsigned(3 downto 0) := "1110";
    constant Cuint1_t_1 : std_logic := '1';
    constant Cuint4_t_12 : unsigned(3 downto 0) := "1100";
    constant Cuint4_t_15 : unsigned(3 downto 0) := "1111";
  begin
    PC_pcw_cntrl_nxtpc_pdg_en_out <= '0';
    jump_pc := (others => '0');
    pcw_out <= (others => '0');
    pm_addr_out <= (others => '0');
    pm_ld_pdg_en_out <= '0';
    pdg_we_r_fetched <= '0';
    pdg_update_r_fetched <= '0';
    t := (others => '0');
    t_0 := (others => '0');
    PC_IF_l := pcr_in;
    br_EX := en_jump_of13_cd_sig;
    jalr_ID := en_jump_trgt_sig;
    jal_ID := en_jump_of21_sig;

    -- synopsys translate_off
    if (falling_edge(clock)) and not(reset /= '0') then
      assert((((resize(std_logic_to_unsigned(boolean_to_std_logic(br_EX)), 8) + resize(std_logic_to_unsigned((boolean_to_std_logic(jal_ID) and (not boolean_to_std_logic(br_EX)))), 8)) + resize(std_logic_to_unsigned((boolean_to_std_logic(jalr_ID) and (not boolean_to_std_logic(br_EX)))), 8)) <= Cuint8_t_1))
        report "PDG_ASSERT (trv32p3_cnn_pcu.p:L180:C2) : " & "Assertion triggered!"
        severity failure;
    end if;
    -- synopsys translate_on
    incr_pc := (PC_IF_l + Cuint32_t_4);
    leave_dbg := (r_state = Cuint4_t_14);
    jump_pc := PC_IF_l;
    if (leave_dbg) then
      jump_pc := PC_IF_l;
    else
      if (br_EX) then
        jump_pc := unsigned(jmp_tgt_EX_in);
      else
        if (jalr_ID) then
          jump_pc := unsigned(jmp_tgt_ID_in);
        else
          if (jal_ID) then
            jump_pc := unsigned(jmp_tgt_ID_in);
          end if;
        end if;
      end if;
    end if;
    jump := ((br_EX or jal_ID) or jalr_ID);
    if (jump) then
      t := jump_pc;
    else
      t := incr_pc;
    end if;
    next_pc := t;
    could_issue := (std_logic_to_boolean(issue_sig_in) and (not std_logic_to_boolean(hzd_stall_in)));
    could_jump := ((br_EX or (jalr_ID and (not std_logic_to_boolean(hzd_stall_in)))) or (jal_ID and (not std_logic_to_boolean(hzd_stall_in))));
    instr_avail := std_logic_to_boolean(r_fetched);
    update_pc := (((could_issue and instr_avail) and (not std_logic_to_boolean(t_stop_issue))) or could_jump);
    if (update_pc) then
      PC_pcw_cntrl_nxtpc_pdg_en_out <= Cuint1_t_1;
      pcw_out <= next_pc;
    end if;
    ocd_issue_stall := (r_state = Cuint4_t_12);
    fetch_next := (((could_issue and instr_avail) and (not ocd_issue_stall)) or could_jump);
    if (fetch_next) then
      t_0 := next_pc;
    else
      t_0 := PC_IF_l;
    end if;
    fetch_pc := t_0;
    fetch := (r_state /= Cuint4_t_15);
    pdg_we_r_fetched <= '1';
    pdg_update_r_fetched <= boolean_to_std_logic(fetch);
    pm_addr_out <= fetch_pc;
    if (fetch) then
      pm_ld_pdg_en_out <= Cuint1_t_1;
    end if;
  end process user_next_pc;


  p_update_status : process(clock, reset)
  begin
    if reset /= '0' then
      r_booting <= '1';
      r_fetched <= '0';
      r_state <= (others => '0');
    elsif clock'event and clock = '1' then
      if pdg_we_r_booting = '1' then
        r_booting <= pdg_update_r_booting;
      end if;
      if pdg_we_r_fetched = '1' then
        r_fetched <= pdg_update_r_fetched;
      end if;
      if pdg_we_r_state = '1' then
        r_state <= pdg_update_r_state;
      end if;
    end if;
  end process p_update_status;

  -- End of code generated by pdg.
end rtl;
